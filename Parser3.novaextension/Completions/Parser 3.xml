<?xml version="1.0" encoding="UTF-8"?>
<completions>

	<!-- "[foo]" -->
	<provider name="constant">
		<syntax>parser3</syntax>
		<selector>*:not(comment, directives.block.taint, directives.block.untaint, directives.block.apply-taint)</selector>
		<expression>(?&lt;=\[)([a-zA-Z-]+)(?=;|\])</expression>
		<symbols type="property" />
		<set>parser3.keywords.property</set>
	</provider>

	<!-- .foo -->
	<provider name="instance.property">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\.)([a-zA-Z_][a-zA-Z-_]*)</expression>
		<symbols type="property" />
		<set>parser3.instance.property</set>
	</provider>

	<!-- .foo[ -->
	<provider name="instance.method">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=[\w\]]\.)([a-zA-Z-]+)</expression>
		<set>parser3.instance.method</set>
	</provider>

	<!-- "@foo" -->	
	<provider name="core.method">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=^\@)([a-zA-Z_]+)</expression>
		<symbols type="method" />
		<set>parser3.core.method</set>
	</provider>

	<!-- "$foo" -->
	<provider name="variable">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\$)(?!(result|exception|key|value|CLASS_PATH|LIMITS|MAIN|MAIL|MIME-TYPES|SQL)\b)(([a-zA-Z0-9_][a-zA-Z0-9_]*)?)</expression>
		<symbols type="variable,argument" />
		<set>parser3.core.variables</set>
	</provider>

<!-- doesn't work :-( -->	
<!-- 
	<provider name="arguments">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\$)([a-zA-Z0-9_][a-zA-Z0-9_]*)</expression>
		<symbols type="argument" />
	</provider>
 -->
 
	<provider name="variable.bracket">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\$\{)(?!(result|exception|key|value|CLASS_PATH|LIMITS|MAIN|MAIL|MIME-TYPES|SQL)\b)(([a-zA-Z0-9_][a-zA-Z0-9_]*\.?)?)</expression>
		<symbols type="variable,argument" />
		<set>parser3.core.variables</set>
	</provider>

	<!-- "$.foo[({" -->
	<provider name="options">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<!-- <selector>directives.block.hash</selector> -->
		<expression>(?&lt;=\$\.)(([a-zA-Z_][a-zA-Z_-]*)?)</expression>		
		<set>parser3.core.options</set>
	</provider>


<!-- ^foo[a;b;c] -->

	<provider name="method">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^)\b([a-zA-Z_][a-zA-Z0-9_-]*)</expression>
		<symbols type="method">
			<behavior>
				<arguments prefix="[" suffix="]" separator=";" />
			</behavior>
		</symbols>
		<symbols type="variable" />
		<symbols type="argument" />
		<set>parser3.core.methods</set>
	</provider>
	
<!-- "^classes" -->
	<provider name="classes">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^)([a-zA-Z_-]+)</expression>
		<symbols type="class" />
		<set>parser3.core.classes</set>
	</provider>

<!-- "^classes" -->
	<provider name="custom.classes">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^)([a-zA-Z_-]+)</expression>
		<symbols type="class" />
		<set>parser3.custom.classes.</set>
	</provider>
	
<!-- "$classes" -->
	<provider name="classes.static">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\$)([a-zA-Z]+)</expression>
		<symbols type="class" />
		<set>parser3.core.classes.static</set>
	</provider>

<!-- "SQL" -->
	<provider name="sql">
		<syntax>parser3</syntax>
		<selector>directives.block.sql</selector>
		<expression>(?&lt;=\s)([a-zA-Z_][a-zA-Z0-9-_]*)</expression>
		<set>parser3.sql</set>
		<set>parser3.sql.types</set>
	</provider>


<!-- Logic -->  
	<provider name="constant">
		<syntax>parser3</syntax>
		<selector>directives.block.logic</selector>
		<expression>([a-zA-Z-]+)</expression>
		<set>parser3.core.operator.logic</set>
		<set>parser3.core.boolean</set>
		<set>parser3.keywords.exception.types</set>
		<set>parser3.keywords.class.types</set>
	</provider>
	
<!-- ^date -->

	<provider name="date">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^date\:)(\:?[a-z-]+)</expression>
		<symbols type="method" />
		<set>parser3.core.date</set>
	</provider>

<!-- ^double -->

	<provider name="double">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^double\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.double</set>
	</provider>

<!-- ^int -->

	<provider name="int">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^int\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.int</set>
	</provider>

<!-- $env -->

	<provider name="env">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\$env\:)([a-zA-Z0-9_]+)</expression>
		<symbols type="property" />
		<set>parser3.core.env</set>
	</provider>
	
	<provider name="env.method">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^env\:)([a-zA-Z0-9_]+)</expression>
		<symbols type="property" />
		<set>parser3.core.env.method</set>
	</provider>

<!-- $console -->

	<provider name="console">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\$console\:)([a-z]+)</expression>
		<symbols type="property,method" />
		<set>parser3.core.console.static</set>
	</provider>

<!-- "$cookie" -->

	<provider name="cookie">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\$cookie\:)([a-z]+)</expression>
		<symbols type="property" />
		<set>parser3.core.cookie</set>
	</provider>
	
	<provider name="cookie.static">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^cookie\:)([a-z]+)</expression>
		<symbols type="property" />
		<set>parser3.core.cookie.static</set>
	</provider>
   
<!-- "^curl" -->
	<provider name="curl">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^curl\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.curl</set>
	</provider>
	
<!-- "^file:" -->
	<provider name="file">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^file\:)(\:?[a-z0-9]+)</expression>
		<symbols type="method" />
		<set>parser3.core.file</set>
	</provider>

<!-- "^form:" -->
	<provider name="form">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\$form\:)([a-z]+)</expression>
		<symbols type="property" />
		<set>parser3.core.form</set>
	</provider>
	
	<provider name="form.static">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^form\:)([a-z]+)</expression>
		<symbols type="property" />
		<set>parser3.core.form.static</set>
	</provider>

<!-- "^hash::" -->
	<provider name="hash">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^hash\:\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.hash</set>
	</provider>

<!-- "^hashfile::" -->
	<provider name="hashfile">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^hashfile\:\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.hashfile</set>
	</provider>

<!-- "^image::" -->
	<provider name="image">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^image\:\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.image</set>
	</provider>

<!-- "^inet:" -->
	<provider name="inet">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^inet\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.inet</set>
	</provider>

<!-- "^json:" -->
	<provider name="json">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^json\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.json</set>
	</provider>

<!-- "^mail:" -->
	<provider name="mail">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^mail\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.mail</set>
	</provider>

<!-- "^math:" -->
	<provider name="math">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^math\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.math</set>
	</provider>

	<provider name="math.static">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\$math\:)([a-z]+)</expression>
		<symbols type="property" />
		<set>parser3.core.math.static</set>
	</provider>

<!-- "^memcached:" -->

	<provider name="memcached">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^memcached\:\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.memcached</set>
	</provider>

<!-- "^memory:" -->

	<provider name="memory">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^memory\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.memory</set>
	</provider>

<!-- "^reflection:" -->

	<provider name="reflection">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^reflection\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.reflection</set>
	</provider>

<!-- "^regex::" -->

	<provider name="reflection">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^regex\:\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.regex</set>
	</provider>

<!-- "$request:" -->
<!-- "^request:" -->

	<provider name="request">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^request\:)([a-z-]+)</expression>
		<symbols type="method" />
		<set>parser3.core.request</set>
	</provider>
	
	<provider name="request">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\$request\:)([a-z-]+)</expression>
		<symbols type="method" />
		<set>parser3.core.request.static</set>
	</provider>

<!-- "$response:" -->
<!-- "^response:" -->

	<provider name="response">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^response\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.response</set>
	</provider>
	
	<provider name="response">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\$response\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.response.static</set>
	</provider>

<!-- "$status:" -->
<!-- "^status:" -->

	<provider name="status">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^status\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.status</set>
	</provider>
	
	<provider name="status">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\$status\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.status.static</set>
	</provider>

<!-- "^string" -->
	<provider name="string">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^string\:)([a-z0-9-]+)</expression>
		<symbols type="method" />
		<set>parser3.core.string</set>
	</provider>

<!-- "^taint" -->
	<provider name="taint-transformation-type">
		<syntax>parser3</syntax>
		<selector>directives.block.taint, directives.block.untaint, directives.block.apply-taint</selector>
		<expression>(?&lt;=\[)[a-z\-]*(?=\])</expression>
		<set>parser3.core.taint.transformation-type</set>
	</provider> 
	
<!-- "^table" -->
	<provider name="table">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^table\:\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.table</set>
	</provider>

<!-- "^void" -->
	<provider name="void">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^void\:)([a-z]+)</expression>
		<symbols type="method" />
		<set>parser3.core.void</set>
	</provider>

<!-- "^xdoc" -->
	<provider name="xdoc">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\^xdoc\:\:)([a-z0-9-]+)</expression>
		<symbols type="method" />
		<set>parser3.core.xdoc</set>
	</provider>
	
<!-- "$xdoc" -->
	<provider name="xdoc">
		<syntax>parser3</syntax>
		<selector>*:not(comment)</selector>
		<expression>(?&lt;=\$xdoc\:)([a-z0-9-]+)</expression>
		<!-- <symbols type="constant" /> -->
		<set>parser3.core.xdoc.constant</set>
	</provider>
	
<!-- SETS -->

	<set name="parser3.core.boolean" symbol="constant">
		<completion string="true" />
		<completion string="false" />
	</set>
   
	<set name="parser3.core.operator.logic" symbol="constant">
		<completion string="def">
			<behavior>
				<append> </append>
			</behavior>
		</completion>
		<completion string="eq">
			<behavior>
				<append> </append>
			</behavior>
		</completion>
		<completion string="ne">
			<behavior>
				<append> </append>
			</behavior>
		</completion>
		<completion string="is">
			<behavior>
				<append> </append>
			</behavior>
		</completion>
		<completion string="in">
			<behavior>
				<append> </append>
			</behavior>
		</completion>
		<completion string="lt">
			<behavior>
				<append> </append>
			</behavior>
		</completion>
		<completion string="qt">
			<behavior>
				<append> </append>
			</behavior>
		</completion>
		<completion string="le">
			<behavior>
				<append> </append>
			</behavior>
		</completion>
		<completion string="ge">
			<behavior>
				<append> </append>
			</behavior>
		</completion>
		<completion string="-d">
			<behavior>
				<append> </append>
			</behavior>
		</completion>
		<completion string="-f">
			<behavior>
				<append> </append>
			</behavior>
		</completion>
	</set>
	
	<set name="parser3.core.variables" symbol="variable">
		<completion string="CLASS_PATH" />
		<completion string="MAIN" />
		<completion string="LIMITS" />
		<completion string="MAIL" />
		<completion string="SQL" />
		<completion string="MIME-TYPES" />
		<completion string="key" />
		<completion string="value" />
		<completion string="result" />
		<completion string="exception" />
	</set>

	<set name="parser3.core.options" symbol="property">
		<completion string="array">
			<description>json:parse parameter. If defined the specified method will be called for every parsing array.</description>
			<behavior>
				<append>[$[method name]]</append>
			</behavior>
		</completion>
		<completion string="any-status">
			<description>If boolean is false, and received status is not equal to 200, system exception http.status will be thrown.</description>
			<behavior>
				<append>(true)</append>
			</behavior>
		</completion>
		<completion string="accept_encoding">
			<description>curl parameter (CURLOPT_ACCEPT_ENCODING). Compresion for the request: gzip or deflate.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="autoreferer">
			<description>curl parameter (CURLOPT_AUTOREFERER). Set the Referer header automatically.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="bind">
			<description>void:sql, string:sql, table::sql parameter</description>
			<behavior>
				<append>[hash]</append>
			</behavior>
		</completion>
		<completion string="body">
			<description>Text body of the query.</description>
			<behavior>
				<append>[$[string]]</append>
			</behavior>
		</completion>
		<completion string="binary-protocol">
			<description>memcached::open parameter</description>
			<behavior>
				<append>($[true|false])</append>
			</behavior>
		</completion>
		<completion string="cainfo">
			<description>curl parameter (CURLOPT_CAINFO)</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="capath">
			<description>curl parameter (CURLOPT_CAPATH)</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="charset">
			<description></description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="class-name">
			<description>json:string parameter. Objects of any class (including mentioned date, table and file) could be serialized with user's method.</description>
			<behavior>
				<append>[$[method name]]</append>
			</behavior>
		</completion>
		<completion string="colon">
			<description>date.iso-string parameter. Exclude the colon from the time zone. By default, do not exclude.</description>
			<behavior>
				<append>($[true|false])</append>
			</behavior>
		</completion>
		<completion string="content-type">
			<description>curl:options, curl:load parameter</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="connecttimeout">
			<description>curl parameter (CURLOPT_CONNECTTIMEOUT). The maximum time in seconds that you allow the connection to the server to take.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="connecttimeout_ms">
			<description>curl parameter (CURLOPT_CONNECTTIMEOUT_MS). The maximum time in milliseconds that you allow the connection to the server to take.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="connect-timeout">
			<description>memcached::open parameter</description>
			<behavior>
				<append>($[seconds])</append>
			</behavior>
		</completion>
		<completion string="cookie">
			<description>curl parameter (CURLOPT_COOKIE). String with cookies (name1=content1; name2=content2;...).</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="cookies">
			<description>Hash with list of cookies to be passed to HTTP-server.</description>
			<behavior>
				<append>($[hash])</append>
			</behavior>
		</completion>
		<completion string="cookielist">
			<description>curl parameter (CURLOPT_COOKIELIST). String with cookies.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="cookiesession">
			<description>curl parameter (CURLOPT_COOKIESESSION)</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="copypostfields">
			<description>curl parameter (CURLOPT_COPYPOSTFIELDS). The body of POST-request.</description>
			<behavior>
				<append>[$[string or file]]</append>
			</behavior>
		</completion>
		<completion string="crlfile">
			<description>curl parameter (CURLOPT_CRLFILE)</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="customrequest">
			<description>curl parameter (CURLOPT_CUSTOMREQUEST). Custom HTTP method.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="date">
			<description>json:string parameter. Defines format of objects of class date (see the methods of class date with the same names).</description>
			<behavior>
				<append>[$[sql-string|gmt-string|iso-string|unix-timestamp]]</append>
			</behavior>
		</completion>
		<completion string="default">
			<description></description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="default">
			<description></description>
			<behavior>
				<append>{$[]}</append>
			</behavior>
		</completion>
		<completion string="depth">
			<description>json:parse parameter. Maximum depth. Default is 19.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="double">
			<description>json:parse parameter. Stores real numbers as objects of class double. Default is true.</description>
			<behavior>
				<append>($[false|true])</append>
			</behavior>
		</completion>
		<completion string="distinct">
			<description>hash::sql, table.hash parameter</description>
			<behavior>
				<append>($[true|false])</append>
			</behavior>
		</completion>
		<completion string="distinct">
			<description>json:parse parameter. The way of processing elements with identical names.</description>
			<behavior>
				<append>[$[first|last|al]]</append>
			</behavior>
		</completion>
		<completion string="domain">
			<description>cookie parameter. Specifies domain from which the cookie may be accessed.</description>
			<behavior>
				<append>[$[doman name]]</append>
			</behavior>
		</completion>
		<completion string="encloser">
			<description>table parameter. Specifies column encloser character.</description>
			<behavior>
				<append>[$[symbol]]</append>
			</behavior>
		</completion>
		<completion string="enctype">
			<description>Possible values are: application/x-www-form-urlencoded or multipart/form-data.</description>
			<behavior>
				<append>[$[content type]]</append>
			</behavior>
		</completion>
		<completion string="encoding">
			<description>xdoc parameter</description>
			<behavior>
				<append>[$[charset]]</append>
			</behavior>
		</completion>
		<completion string="expires">
			<description>hashfile, cookie, memcached parameter</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="expires">
			<description>hashfile, cookie parameter</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="ignore_content_length">
			<description>curl parameter (CURLOPT_IGNORE_CONTENT_LENGTH). Ignore the Content-Length header. This is useful for Apache 1.x which will report incorrect content length for files over 2GB.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="int">
			<description>json:parse parameter. If true, stores integer numbers as objects of class int. If false, stores integer numbers as strings.</description>
			<behavior>
				<append>($[false|true])</append>
			</behavior>
		</completion>
		<completion string="indent">
			<description>json:string parameter. If this option is set to true the resulting JSON-string will be formatted using tab characters.</description>
			<behavior>
				<append>($[false|true])</append>
			</behavior>
		</completion>
		<completion string="indent">
			<description>json:string parameter. The option is also can be specified as user-predefined indent's prefix string.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="indent">
			<description>xdoc parameter</description>
			<behavior>
				<append>[no]</append>
			</behavior>
		</completion>
		<completion string="interface">
			<description>curl parameter (CURLOPT_INTERFACE). Interface name to use as outgoing network interface.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="ipresolve">
			<description>curl parameter (CURLOPT_IPRESOLVE). 1-use IPv4 (default), 2-use IPv6.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="issuercert">
			<description>curl parameter (CURLOPT_ISSUERCERT). Filename holding a CA certificate.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="headers">
			<description>Hash with additional HTTP-headers to be passed to HTTP-server.</description>
			<behavior>
				<append>[$[http-headers hash]]</append>
			</behavior>
		</completion>
		<completion string="html">
			<description>mail:send parameter</description>
			<behavior>
				<append>{$[]}</append>
			</behavior>
		</completion>
		<completion string="httponly">
			<description>cookie parameter</description>
			<behavior>
				<append>(true)</append>
			</behavior>
		</completion>
		<completion string="http_content_decoding">
			<description>curl parameter (CURLOPT_HTTP_CONTENT_DECODING)</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="http_transfer_decoding">
			<description>curl parameter (CURLOPT_HTTP_TRANSFER_DECODING)</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="httpauth">
			<description>curl parameter (CURLOPT_HTTPAUTH). HTTP-authorization method.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="httpget">
			<description>curl parameter (CURLOPT_HTTPGET). Use GET HTTP method.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="httpheader">
			<description>curl parameter (CURLOPT_HTTPHEADER). HTTP-headers.</description>
			<behavior>
				<append>[$[hash]]</append>
			</behavior>
		</completion>
		<completion string="httppost">
			<description>curl parameter (CURLOPT_HTTPPOST). Multipart/formdata HTTP POST to be made to pass data on to the server.</description>
			<behavior>
				<append>[$[hash]]</append>
			</behavior>
		</completion>
		<completion string="httpproxytunnel">
			<description>curl parameter (CURLOPT_HTTPPROXYTUNNEL). Tunnel all operations through a given HTTP proxy.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="failonerror">
			<description>curl parameter (CURLOPT_FAILONERROR). Fail if HTTP code returned is equal or larger then 400.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="file">
			<description></description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="file">
			<description>json:string parameter. Defines format of bodies of objects of class file.</description>
			<behavior>
				<append>[$[text|base64|stat]]</append>
			</behavior>
		</completion>
		<completion string="followlocation">
			<description>curl parameter (CURLOPT_FOLLOWLOCATION). Follow any Location header.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="forbid_reuse">
			<description>curl parameter (CURLOPT_FORBID_REUSE)</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="form">
			<description>Request parameters.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="fresh_connect">
			<description>curl parameter (CURLOPT_FRESH_CONNECT). Next transfer will use a new connection by force.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="from">
			<description>mail:send parameter</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="from-charset">
			<description></description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="keypasswd">
			<description>curl parameter (CURLOPT_KEYPASSWD). The password required to use the private key.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="library">
			<description>curl:options, curl:load parameter. Full path to dynamical libcurl library.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="limit">
			<description>*:sql, reflection:stack, table::create, table.join, table.locate, table.select parameter</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="lineno">
			<description>process parameter. A line number in file, where this string cames from. May be negative.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="localport">
			<description>curl parameter (CURLOPT_LOCALPORT). Local port.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="low_speed_limit">
			<description>curl parameter (CURLOPT_LOW_SPEED_LIMIT). The transfer speed in bytes per second during low_speed_time.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="low_speed_time">
			<description>curl parameter (CURLOPT_LOW_SPEED_TIME). The maxinum time in seconds that the transfer should be below the low_speed_limit for the library to consider it is too slow and abort.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="maxconnects">
			<description>curl parameter (CURLOPT_MAXCONNECTS). The maximum amount of simultaneously open connections. </description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="maxfilesize">
			<description>curl parameter (CURLOPT_MAXFILESIZE). If the file requested is larger than this value, the transfer will not start.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="maxredirs">
			<description>curl parameter (CURLOPT_MAXREDIRS). Maximum number or redirects.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="main">
			<description>process parameter. A new name for main method, declared in code in string.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="mode">
			<description>file::create, curl:options, curl:load parameter. The mode of the created file object.</description>
			<behavior>
				<append>[$[text|binary]]</append>
			</behavior>
		</completion>
		<completion string="method">
			<description>The name of HTTP-method should be specified in uppercase only.</description>
			<behavior>
				<append>[$[GET|POST]]</append>
			</behavior>
		</completion>
		<completion string="method">
			<description>xdoc parameter</description>
			<behavior>
				<append>[html]</append>
			</behavior>
		</completion>
		<completion string="ms">
			<description>date.iso-string parameter. Add milliseconds, always .000  (2002-04-29T12:00:00.000+03:00). By default, do not add.</description>
			<behavior>
				<append>($[false|true])</append>
			</behavior>
		</completion>
		<completion string="name">
			<description></description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="nobody">
			<description>curl parameter (CURLOPT_NOBODY). Use HEAD method.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="type">
			<description></description>
			<behavior>
				<append>[$[hash|string|table]]</append>
			</behavior>
		</completion>
		<completion string="to">
			<description>mail:send parameter</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="to-charset">
			<description></description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="tcp-keepalive">
			<description>memcached parameter</description>
			<behavior>
				<append>($[false|true])</append>
			</behavior>
		</completion>
		<completion string="range">
			<description>curl parameter (CURLOPT_RANGE). The specified range you want.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="referer">
			<description>curl parameter (CURLOPT_REFERER). Referer header.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="replace">
			<description>process parameter. The exception occurs in case of loading class if a class with the same name was already loaded</description>
			<behavior>
				<append>($[false|true])</append>
			</behavior>
		</completion>
		<completion string="reverse">
			<description>reflection:methods, table::create, table.join, table.locate, table.select parameter</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="response-charset">
			<description>Force specify charset for response body.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="object">
			<description>json:parse parameter. If defined the specified method will be called for every parsing object.</description>
			<behavior>
				<append>[$[method name]]</append>
			</behavior>
		</completion>
		<completion string="offset">
			<description>*:sql, reflection:stack, table::create, table.join, table.locate, table.select parameter</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="omit-post-charset">
			<description>Don't add charset info to HTTP-header content-type for outgoing POST request.</description>
			<behavior>
				<append>(true)</append>
			</behavior>
		</completion>
		<completion string="omit-xml-declaration">
			<description>xdoc parameter</description>
			<behavior>
				<append>[yes]</append>
			</behavior>
		</completion>
		<completion string="options">
			<description></description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="path">
			<description>cookie parameter. Specifies subsection of the site from which the cookie may be accessed.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="password">
			<description>These are request parameters to server, which uses standard HTTP-authorization.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="password">
			<description>curl parameter (CURLOPT_PASSWORD). Password.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="post">
			<description>curl parameter (CURLOPT_POST). Use POST method.</description>
			<behavior>
				<append>(1)</append>
			</behavior>
		</completion>
		<completion string="port">
			<description>curl parameter (CURLOPT_PORT). Port.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="postfields">
			<description>curl parameter (CURLOPT_POSTFIELDS). The body of POST-request.</description>
			<behavior>
				<append>[$[string or file]]</append>
			</behavior>
		</completion>
		<completion string="postredir">
			<description>curl parameter (CURLOPT_POSTREDIR)</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="proxy">
			<description>curl parameter (CURLOPT_PROXY). Proxy-server address.</description>
			<behavior>
				<append>[$[string]]</append>
			</behavior>
		</completion>
		<completion string="proxyauth">
			<description>curl parameter (CURLOPT_PROXYAUTH). Authorization type (see httpauth).</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="proxyport">
			<description>curl parameter (CURLOPT_PROXYPORT). Proxy-server port.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="proxytype">
			<description>curl parameter (CURLOPT_PROXYTYPE). Proxy type: 0 - HTTP, 1 - HTTP_1_0, 4 - SOCKS4, 5 - SOCKS5, 6 - SOCKS4A, 7 - SOCKS5_HOSTNAME. </description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="proxyuserpwd">
			<description>curl parameter (CURLOPT_PROXYUSERPWD). Proxy-server user name and password.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="print-debug">
			<description>mail:send parameter. The message text will be printed instead of sending message.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="skip-unknown">
			<description>json:string parameter. By default (false) only the objects of classes void, bool, string, int, double, date, table, hash Ð¸ file are accepted.</description>
			<behavior>
				<append>($[false|true])</append>
			</behavior>
		</completion>
		<completion string="server">
			<description></description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="ssl_cipher_list">
			<description>curl perameter (CURLOPT_SSL_CIPHER_LIST)</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="ssl_sessionid_cache">
			<description>curl perameter (CURLOPT_SSL_SESSIONID_CACHE). Enable or disable SSL session-ID caching.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="ssl_verifyhost">
			<description>curl perameter (CURLOPT_SSL_VERIFYHOST). Verifies that the server cert is for the server it is known as.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="ssl_verifypeer">
			<description>curl perameter (CURLOPT_SSL_VERIFYPEER). Verifies the authenticity of the peer's certificate.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="sslcert">
			<description>curl perameter (CURLOPT_SSLCERT). File name of your certificate.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="sslcerttype">
			<description>curl perameter (CURLOPT_SSLCERTTYPE). SSL-certificate type.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="sslengine">
			<description>curl perameter (CURLOPT_SSLENGINE)</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="sslengine_default">
			<description>curl perameter (CURLOPT_SSLENGINE_DEFAULT)</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="sslkey">
			<description>curl perameter (CURLOPT_SSLKEY). File name of your private key.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="sslkeytype">
			<description>curl perameter (CURLOPT_SSLKEYTYPE). SSL-key type.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="sslversion">
			<description>curl perameter (CURLOPT_SSLVERSION). Protocol version for SSL/TLS connection: 0 - default, 1 - TLSv1 (TLS 1.x), 2 - SSLv2, 3 - SSLv3, 4 - TLSv1_0, 5 - TLSv1_1, 6 - TLSv1_2.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="stderr">
			<description>curl perameter (CURLOPT_STDERR). Redirect stderr into specified stream.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="separator">
			<description>table parameter. Specifies column separator character.</description>
			<behavior>
				<append>[$[symbol]]</append>
			</behavior>
		</completion>
		<completion string="subject">
			<description>mail:send parameter</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="taint">
			<description>json:parse parameter. Defines the transformation type for all strings in the output.</description>
			<behavior>
				<append>[$[type]]</append>
			</behavior>
		</completion>
		<completion string="table">
			<description>json:string parameter. Defines format of objects of class table.</description>
			<behavior>
				<append>[$[object|array|compact]]</append>
			</behavior>
		</completion>
		<completion string="text">
			<description>mail:send parameter</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="timeout">
			<description>curl parameter (CURLOPT_TIMEOUT). Timeout in seconds.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="timeout_ms">
			<description>curl parameter (CURLOPT_TIMEOUT_MS). Timeout in miliseconds.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="value">
			<description></description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="void">
			<description>json:string parameter. Defines format of objects of class void.</description>
			<behavior>
				<append>[$[null|string]]</append>
			</behavior>
		</completion>
		<completion string="user">
			<description>These are request parameters to server, which uses standard HTTP-authorization.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="unrestricted_auth">
			<description>curl parameter (CURLOPT_UNRESTRICTED_AUTH). Continue to send authentication when following locations, even when hostname changed.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="url">
			<description>curl parameter (CURLOPT_URL)</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="useragent">
			<description>curl parameter (CURLOPT_USERAGENT). User-Agent header.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="username">
			<description>curl parameter (CURLOPT_USERNAME). User name.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="userpwd">
			<description>curl parameter (CURLOPT_USERPWD). User name and password.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="verbose">
			<description>curl parameter (CURLOPT_VERBOSE). Display a lot of verbose information about its operations into stderr.</description>
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="z">
			<description>date.iso-string parameter. Write the UTC time zone as 00:00 (2002-04-29T09:00:00+00:00)</description>
			<behavior>
				<append>($[false|true])</append>
			</behavior>
		</completion>
		<completion string="xdoc">
			<description>json:string parameter. Options for converting into text.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="_default">
			<description>Default hash key.</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="_default">
			<description>json:string parameter</description>
			<behavior>
				<append>[$[method reference or name]]</append>
			</behavior>
		</completion>
	</set>

	<set name="parser3.core.method" symbol="method">
		<completion string="auto">
			<behavior>
				<append>[]
$[]</append>
			</behavior>
		</completion>
		<completion string="BASE">
			<behavior>
				<append>
$[]</append>
			</behavior>
		</completion>
		<completion string="CLASS">
			<behavior>
				<append>
$[]</append>
			</behavior>
		</completion>
		<completion string="create">
			<behavior>
				<append>[]
$[]</append>
			</behavior>
		</completion>
		<completion string="main">
			<behavior>
				<append>[]
$[]</append>
			</behavior>
		</completion>
		<completion string="postprocess">
			<behavior>
				<append>[body]
$[]</append>
			</behavior>
		</completion>
		<completion string="OPTIONS">
			<behavior>
				<append>
$[]</append>
			</behavior>
		</completion>
		<completion string="static">
			<behavior>
				<append>:$[name][]</append>
			</behavior>
		</completion>
		<completion string="USE">
			<behavior>
				<append>
$[]</append>
			</behavior>
		</completion>
		<completion string="unhandled_exception">
			<behavior>
				<append>[exception;stack]
$[]</append>
			</behavior>
		</completion>
	</set>
	
	<set name="parser3.keywords.class.types" symbol="constant">
		<completion string="cookie" />
		<completion string="curl" />
		<completion string="date" />
		<completion string="double" />
		<completion string="int" />
		<completion string="env" />
		<completion string="file" />
		<completion string="form" />
		<completion string="hash" />
		<completion string="hashfile" />
		<completion string="image" />
		<completion string="inet" />
		<completion string="json" />
		<completion string="mail" />
		<completion string="math" />
		<completion string="memcached" />
		<completion string="memory" />
		<completion string="reflection" />
		<completion string="regex" />
		<completion string="request" />
		<completion string="response" />
		<completion string="status" />
		<completion string="string" />
		<completion string="table" />
		<completion string="void" />
		<completion string="xdoc" />
	</set>
	
	<set name="parser3.keywords.property" symbol="property">
		<completion string="text" />
		<completion string="binary" />
		<completion string="UTF-8" />
		<completion string="first" />
		<completion string="last" />
		<completion string="key" />
		<completion string="value" />
		<completion string="hash" />
		<completion string="desc" />
		<completion string="asc" />
	</set>
	
	<set name="parser3.keywords.exception.types" symbol="constant">
		<completion string="parser.compile" />
		<completion string="parser.runtime" />
		<completion string="parser.interrupted" />
		<completion string="number.zerodivision " />
		<completion string="number.format" />
		<completion string="file.missing" />
		<completion string="file.access" />
		<completion string="file.read" />
		<completion string="file.execute" />
		<completion string="date.range" />
		<completion string="pcre.execute" />
		<completion string="image.format" />
		<completion string="sql.connect" />
		<completion string="sql.execute" />
		<completion string="xml" />
		<completion string="smtp.connect" />
		<completion string="smtp.execute" />
		<completion string="email.format" />
		<completion string="email.send" />
		<completion string="http.host" />
		<completion string="http.connect" />
		<completion string="http.response" />
		<completion string="http.status" />
		<completion string="http.timeout" />
		<completion string="curl.host" />
		<completion string="curl.connect" />
		<completion string="curl.status" />
		<completion string="curl.ssl" />
		<completion string="curl.timeout" />
		<completion string="curl.fail" />
	</set>

	<set name="parser3.instance.property" symbol="property">
	
		<completion string="fields" />
		<completion string="name" />
		<!-- date -->
		<completion string="month" description="date field" />
		<completion string="year" description="date field" />
		<completion string="day" description="date field" />
		<completion string="hour" description="date field" />
		<completion string="minute" description="date field" />
		<completion string="second" description="date field" />
		<completion string="weekday" description="date field" />
		<completion string="week" description="date field" />
		<completion string="weekyear" description="date field" />
		<completion string="yearday" description="date field" />
		<completion string="daylightsaving" description="date field" />
		<completion string="TZ" description="date field" />
		
		<!-- exception -->
		<completion string="type" description="exception field" />
		<completion string="source" description="exception field" />
		<completion string="file" description="exception field" />
		<completion string="lineno" description="exception field" />
		<completion string="colno" description="exception field" />
		<completion string="comment" description="exception field" />
		<completion string="handled" description="exception field" />
		
		<!-- file -->

		<completion string="size" description="file field" />
		<completion string="text" description="file field" />
		<completion string="cdate" description="file field" />
		<completion string="mdate" description="file field" />
		<completion string="adate" description="file field" />
		<completion string="stderr" description="file field" />
		<completion string="status" description="file field" />
		<completion string="mode" description="file field" />
		<completion string="content-type" description="file field" />
		<completion string="SERVER" description="file field" />
		<!-- hash -->
		<completion string="_default" description="hash field" />
		<!-- image -->
		<completion string="src" description="image field" />
		<completion string="width" description="image field" />
		<completion string="height" description="image field" />
		<completion string="exif" description="image field" />
		<!-- status -->
		<completion string="utime" description="status field" />
		<completion string="stime" description="status field" />
		<completion string="maxrss" description="status field" />
		<completion string="tv_sec" description="status field" />
		<completion string="tv_usec" description="status field" />
		<completion string="used" description="status field" />
		<completion string="free" description="status field" />
		<completion string="ever_allocated_since_compact" description="status field" />
		<completion string="ever_allocated_since_start" description="status field" />
		<!-- xdoc -->
		<completion string="doctype" description="xdoc field" />
		<completion string="documentElement" description="xdoc field" />
		<completion string="search-namespaces" description="xdoc field" />
		<!-- xnode -->
		<completion string="nodeName" description="xnode field (DOM1-interface Node)" />
		<completion string="nodeValue" description="xnode field (DOM1-interface Node)" />
		<completion string="nodeType" description="xnode field (DOM1-interface Node)" />
		<completion string="parentNode" description="xnode field (DOM1-interface Node)" />
		<completion string="childNodes" description="xnode field (DOM1-interface Node)" />
		<completion string="firstChild" description="xnode field (DOM1-interface Node)" />
		<completion string="lastChild" description="xnode field (DOM1-interface Node)" />
		<completion string="previousSibling" description="xnode field (DOM1-interface Node)" />
		<completion string="nextSibling" description="xnode field (DOM1-interface Node)" />
		<completion string="attributes" description="xnode field (DOM1-interface Node)" />
		<completion string="ownerDocument" description="xnode field (DOM1-interface Node)" />
		<completion string="prefix" description="xnode field (DOM2-interface Node)" />
		<completion string="namespaceURI" description="xnode field (DOM2-interface Node)" />
		<completion string="tagName" description="xnode field (DOM1-interface Element)" />
		<!-- <completion string="name" description="xnode field (DOM1-interface Attr)" /> -->
		<completion string="specified" description="xnode field (DOM1-interface Attr)" />
		<completion string="value" description="xnode field (DOM1-interface Attr)" />
		<completion string="target" description="xnode field (DOM1-interface ProcessingInstruction)" />
		<completion string="data" description="xnode field (DOM1-interface ProcessingInstruction)" />
		<completion string="entities" description="xnode field (DOM1-interface DocumentType)" />
		<completion string="notations" description="xnode field (DOM1-interface DocumentType)" />
		<completion string="publicId" description="xnode field (DOM1-interface Notation)" />
		<completion string="systemId" description="xnode field (DOM1-interface Notation)" />
	</set>


	<set name="parser3.instance.method" symbol="method">
		<!-- exception -->
		<completion string="handled">
			<description>exception</description>
			<behavior>
				<append>(true)</append>
			</behavior>
		</completion>
		
		<!-- file -->
		<completion string="base64">
			<description>file</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="crc32">
			<description>file</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		
		<completion string="md5">
			<description>file</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="sql-string">
			<description>file</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="save">
			<description>file</description>
			<behavior>
				<append>[$[text|binary];$[filename]]</append>
			</behavior>
		</completion>
		<completion string="save">
			<description>file</description>
			<behavior>
				<append>[$[text|binary];$[filename];
	$.charset[$[charset]]
]</append>
			</behavior>
		</completion>

<!-- date -->
		<completion string="gmt-string">
			<description>date</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="iso-string">
			<description>date</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="iso-string">
			<description>date</description>
			<behavior>
				<append>[
	$.colon($[true/false])
	$.ms($[false/false])
	$.z($[false/true])
]</append>
			</behavior>
		</completion>
		<completion string="last-day">
			<description>date</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="roll">
			<description>date</description>
			<behavior>
				<append>[$[year|month|day]]($[value])</append>
			</behavior>
		</completion>
		<completion string="roll">
			<description>date</description>
			<behavior>
				<append>[TZ][$[new timezone]]</append>
			</behavior>
		</completion>
		<completion string="sql-string">
			<description>date</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="sql-string">
			<description>date</description>
			<behavior>
				<append>[$[datetime|date|time]]</append>
			</behavior>
		</completion>
		<completion string="unix-timestamp">
			<description>date</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		
<!-- hash -->
		<completion string="_at">
			<description>hash</description>
			<behavior>
				<append>($[number])</append>
			</behavior>
		</completion>
		<completion string="_at">
			<description>hash</description>
			<behavior>
				<append>[$[first|last]]</append>
			</behavior>
		</completion>
		<completion string="at">
			<description>hash</description>
			<behavior>
				<append>($[number])</append>
			</behavior>
		</completion>
		<completion string="at">
			<description>hash</description>
			<behavior>
				<append>[$[first|last]]</append>
			</behavior>
		</completion>
		<completion string="at">
			<description>hash</description>
			<behavior>
				<append>($[number])[$[key|value|hash]]</append>
			</behavior>
		</completion>
		<completion string="at">
			<description>hash</description>
			<behavior>
				<append>[$[first|last];$[key|value|hash]]</append>
			</behavior>
		</completion>
		
		<completion string="_count">
			<description>hash</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="count">
			<description>hash</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="_keys">
			<description>hash</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="_keys">
			<description>hash</description>
			<behavior>
				<append>[$[field]]</append>
			</behavior>
		</completion>
		<completion string="keys">
			<description>hash</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="keys">
			<description>hash</description>
			<behavior>
				<append>[$[field]]</append>
			</behavior>
		</completion>
		<completion string="contains">
			<description>hash</description>
			<behavior>
				<append>[$[key]]</append>
			</behavior>
		</completion>
		<completion string="delete">
			<description>hash</description>
			<behavior>
				<append>[$[key]]</append>
			</behavior>
		</completion>
		<completion string="delete">
			<description>hash</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="foreach">
			<description>hash</description>
			<behavior>
				<append>[key;value]{
	$[]
}</append>
			</behavior>
		</completion>
		<completion string="foreach">
			<description>hash</description>
			<behavior>
				<append>[key;value]{
	$[]
}[$[separator]]</append>
			</behavior>
		</completion>
		<completion string="foreach">
			<description>hash</description>
			<behavior>
				<append>[key;value]{
	$[]
}{
	$[separator]
}</append>
			</behavior>
		</completion>

		<completion string="add">
			<description>hash</description>
			<behavior>
				<append>[$[hash]]</append>
			</behavior>
		</completion>
		<completion string="intersection">
			<description>hash</description>
			<behavior>
				<append>[$[hash]]</append>
			</behavior>
		</completion>
		<completion string="intersects">
			<description>hash</description>
			<behavior>
				<append>[$[hash]]</append>
			</behavior>
		</completion>
		<completion string="sort">
			<description>hash</description>
			<behavior>
				<append>[$[key];$[value]]{
	$[sort function by string]
}</append>
			</behavior>
		</completion>
		<completion string="sort">
			<description>hash</description>
			<behavior>
				<append>[$[key];$[value]]{
	$[sort function by string]
}[$[desc|asc]]</append>
			</behavior>
		</completion>
		<completion string="sort">
			<description>hash</description>
			<behavior>
				<append>[$[key];$[value]](
	$[sort function by number]
)</append>
			</behavior>
		</completion>
		<completion string="sort">
			<description>hash</description>
			<behavior>
				<append>[$[key];$[value]](
	$[sort function by number]
)[$[desc|asc]]</append>
			</behavior>
		</completion>
		<completion string="sub">
			<description>hash</description>
			<behavior>
				<append>[$[hash]]</append>
			</behavior>
		</completion>
		<completion string="union">
			<description>hash</description>
			<behavior>
				<append>[$[hash]]</append>
			</behavior>
		</completion>

<!-- hashfile -->
		<completion string="cleanup">
			<description>hashfile</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="hash">
			<description>hashfile</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
<!-- image -->
		<completion string="gif">
			<description>image</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="gif">
			<description>image</description>
			<behavior>
				<append>[$[filename]]</append>
			</behavior>
		</completion>
		<completion string="html">
			<description>image</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="html">
			<description>image</description>
			<behavior>
				<append>[
	$.border[$[border]]		
	$.alt[$[alter text]]				
]</append>
			</behavior>
		</completion>
		<!-- static -->
		<completion string="line-style">
			<description>image</description>
			<behavior>
				<append>[$[***   ]]</append>
			</behavior>
		</completion>
		<!-- static -->
		<completion string="line-width">
			<description>image</description>
			<behavior>
				<append>($[width])</append>
			</behavior>
		</completion>
		<completion string="arc">
			<description>image</description>
			<behavior>
				<append>($[center x];$[center y];$[width];$[height];$[start in degrees];$[end in degrees];$[color])</append>
			</behavior>
		</completion>
		<completion string="bar">
			<description>image</description>
			<behavior>
				<append>($[x0];$[y0];$[x1];$[y1];$[color])</append>
			</behavior>
		</completion>
		<completion string="copy">
			<description>image</description>
			<behavior>
				<append>[$[src image]]($[x1];$[y1];$[width];$[height];$[x2];$[y2])</append>
			</behavior>
		</completion>
		<completion string="copy">
			<description>image</description>
			<behavior>
				<append>[$[src image]]($[x1];$[y1];$[width 1];$[height 1];$[x2];$[y2];$[width 2];$[height 2];$[color])</append>
			</behavior>
		</completion>
		<completion string="fill">
			<description>image</description>
			<behavior>
				<append>($[x];$[y];$[color])</append>
			</behavior>
		</completion>
		<completion string="font">
			<description>image</description>
			<behavior>
				<append>[$[symbols];$[font image]]($[space width])</append>
			</behavior>
		</completion>
		<completion string="font">
			<description>image</description>
			<behavior>
				<append>[$[symbols];$[font image]]($[space width];$[symbol width])</append>
			</behavior>
		</completion>
		<completion string="font">
			<description>image</description>
			<behavior>
				<append>[$[symbols];$[font image]][
	$.space(0)
	$.width(0)
	$.spacing(0)
]</append>
			</behavior>
		</completion>
		<completion string="length">
			<description>image</description>
			<behavior>
				<append>[$[text]]</append>
			</behavior>
		</completion>
		<completion string="line">
			<description>image</description>
			<behavior>
				<append>($[x0];$[y0];$[x1];$[y1];$[color])</append>
			</behavior>
		</completion>
		<completion string="pixel">
			<description>image</description>
			<behavior>
				<append>($[x];$[y])</append>
			</behavior>
		</completion>
		<completion string="pixel">
			<description>image</description>
			<behavior>
				<append>($[x];$[y];$[color])</append>
			</behavior>
		</completion>
		<completion string="polybar">
			<description>image</description>
			<behavior>
				<append>($[color])[$[coordinates table]]</append>
			</behavior>
		</completion>
		<completion string="polygon">
			<description>image</description>
			<behavior>
				<append>($[color])[$[coordinates table]]</append>
			</behavior>
		</completion>
		<completion string="polyline">
			<description>image</description>
			<behavior>
				<append>($[color])[$[coordinates table]]</append>
			</behavior>
		</completion>
		<completion string="rectangle">
			<description>image</description>
			<behavior>
				<append>($[x0];$[y0];$[x1];$[y1];$[line color])</append>
			</behavior>
		</completion>
		<completion string="replace">
			<description>image</description>
			<behavior>
				<append>($[old color];$[new color])[$[coordinates table]]</append>
			</behavior>
		</completion>
		<completion string="replace">
			<description>image</description>
			<behavior>
				<append>($[old color];$[new color])</append>
			</behavior>
		</completion>
		<completion string="sector">
			<description>image</description>
			<behavior>
				<append>($[center x];$[center y];$[width];$[height];$[start in degrees];$[end in degrees];$[color])</append>
			</behavior>
		</completion>
		<completion string="text">
			<description>image</description>
			<behavior>
				<append>($[x];$[y])[$[text]]</append>
			</behavior>
		</completion>
		
		<!-- memcached -->		
		<completion string="add">
			<description>memcached</description>
			<behavior>
				<append>[$[key];$[value]]</append>
			</behavior>
		</completion>
		<completion string="clear">
			<description>memcached</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="clear">
			<description>memcached</description>
			<behavior>
				<append>($[seconds])</append>
			</behavior>
		</completion>
		<completion string="delete">
			<description>memcached</description>
			<behavior>
				<append>[$[key]]</append>
			</behavior>
		</completion>
		<completion string="mget">
			<description>memcached</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="release">
			<description>memcached</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		
		<!-- string -->
		<completion string="base64">
			<description>string</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="format">
			<description>string</description>
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="int">
			<description>string</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="int">
			<description>string</description>
			<behavior>
				<append>($[default value])</append>
			</behavior>
		</completion>
		<completion string="double">
			<description>string</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="double">
			<description>string</description>
			<behavior>
				<append>($[default value])</append>
			</behavior>
		</completion>
		<completion string="bool">
			<description>string</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="bool">
			<description>string</description>
			<behavior>
				<append>($[default value])</append>
			</behavior>
		</completion>
		<completion string="idna">
			<description>string</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="js-escape">
			<description>string</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="left">
			<description>string</description>
			<behavior>
				<append>($[int])</append>
			</behavior>
		</completion>
		<completion string="right">
			<description>string</description>
			<behavior>
				<append>($[int])</append>
			</behavior>
		</completion>
		<completion string="length">
			<description>string</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="match">
			<description>string</description>
			<behavior>
				<append>[$[pattern]]</append>
			</behavior>
		</completion>
		<completion string="match">
			<description>string</description>
			<behavior>
				<append>[$[pattern]][$[options]]</append>
			</behavior>
		</completion>
		<completion string="match">
			<description>string</description>
			<behavior>
				<append>[$[pattern]][$[options]]{$[replace]}</append>
			</behavior>
		</completion>
		<completion string="match">
			<description>string</description>
			<behavior>
				<append>[$[pattern]][$[options]]{$[replace]}{$[not found]}</append>
			</behavior>
		</completion>
		<completion string="mid">
			<description>string</description>
			<behavior>
				<append>($[position];$[length])</append>
			</behavior>
		</completion>
		<completion string="mid">
			<description>string</description>
			<behavior>
				<append>($[position])</append>
			</behavior>
		</completion>
		<completion string="pos">
			<description>string</description>
			<behavior>
				<append>[$[substring]]</append>
			</behavior>
		</completion>
		<completion string="pos">
			<description>string</description>
			<behavior>
				<append>[$[substring]]($[start position])</append>
			</behavior>
		</completion>
		<completion string="replace">
			<description>string</description>
			<behavior>
				<append>[$[table]]</append>
			</behavior>
		</completion>
		<completion string="replace">
			<description>string</description>
			<behavior>
				<append>[$[from];$[to]]</append>
			</behavior>
		</completion>
		<completion string="save">
			<description>string</description>
			<behavior>
				<append>[$[path]]</append>
			</behavior>
		</completion>
		<completion string="save">
			<description>string</description>
			<behavior>
				<append>[append;$[path]]</append>
			</behavior>
		</completion>
		<completion string="save">
			<description>string</description>
			<behavior>
				<append>[$[path];
	$.charset[$[charset]] 
	$.append($[true|false])
]</append>
			</behavior>
		</completion>
		<completion string="split">
			<description>string</description>
			<behavior>
				<append>[$[separator]]</append>
			</behavior>
		</completion>
		<completion string="split">
			<description>string</description>
			<behavior>
				<append>[$[separator];$[options]]</append>
			</behavior>
		</completion>
		<completion string="split">
			<description>string</description>
			<behavior>
				<append>[$[separator];$[options];$[fieldname]]</append>
			</behavior>
		</completion>
		<completion string="trim">
			<description>string</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="trim">
			<description>string</description>
			<behavior>
				<append>[$[both|left|right]]</append>
			</behavior>
		</completion>
		<completion string="trim">
			<description>string</description>
			<behavior>
				<append>[$[both|left|right];$[symbols]]</append>
			</behavior>
		</completion>
		<completion string="trim">
			<description>string</description>
			<behavior>
				<append>[$[symbols]]</append>
			</behavior>
		</completion>
		<completion string="upper">
			<description>string</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="lower">
			<description>string</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		
		<!-- table -->
		<completion string="append">
			<description>table</description>
			<behavior>
				<append>{$[data]}</append>
			</behavior>
		</completion>
		<completion string="append">
			<description>table</description>
			<behavior>
				<append>[$[data or hash]]</append>
			</behavior>
		</completion>
		<completion string="columns">
			<description>table</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="columns">
			<description>table</description>
			<behavior>
				<append>[$[fieldname]]</append>
			</behavior>
		</completion>
		<completion string="count">
			<description>table</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="count">
			<description>table</description>
			<behavior>
				<append>[$[columns|cells|rows]]</append>
			</behavior>
		</completion>
		<completion string="csv-string">
			<description>table</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="csv-string">
			<description>table</description>
			<behavior>
				<append>[
	$.separator[$[separator symbol]]
	$.encloser[$[encloser symbol]]
]</append>
			</behavior>
		</completion>
		<completion string="csv-string">
			<description>table</description>
			<behavior>
				<append>[nameless]</append>
			</behavior>
		</completion>
		<completion string="csv-string">
			<description>table</description>
			<behavior>
				<append>[nameless;
	$.separator[$[separator symbol]]
	$.encloser[$[encloser symbol]]
]</append>
			</behavior>
		</completion>
		<completion string="flip">
			<description>table</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="hash">
			<description>table</description>
			<behavior>
				<append>[$[key]]</append>
			</behavior>
		</completion>
		<completion string="hash">
			<description>table</description>
			<behavior>
				<append>[$[key]][
	$.type[$[hash|string|table]]
	$.distinct($[0|1])
	$.distinct[tables]				
]</append>
			</behavior>
		</completion>
		<completion string="hash">
			<description>table</description>
			<behavior>
				<append>[$[key]][$[field]]</append>
			</behavior>
		</completion>
		<completion string="hash">
			<description>table</description>
			<behavior>
				<append>[$[key]][$[field]][
	$.type[$[hash|string|table]]
	$.distinct($[0|1])
	$.distinct[tables]				
]</append>
			</behavior>
		</completion>
		<completion string="hash">
			<description>table</description>
			<behavior>
				<append>[$[key]]{$[code]}</append>
			</behavior>
		</completion>
		<completion string="hash">
			<description>table</description>
			<behavior>
				<append>[$[key]]{$[code]}[
	$.type[$[hash|string|table]]
	$.distinct($[0|1])
	$.distinct[tables]				
]</append>
			</behavior>
		</completion>
		<completion string="hash">
			<description>table</description>
			<behavior>
				<append>[$[key]][$[table with fields]]</append>
			</behavior>
		</completion>
		<completion string="hash">
			<description>table</description>
			<behavior>
				<append>[$[key]][$[table with fields]][
	$.type[$[hash|string|table]]
	$.distinct($[0|1])
	$.distinct[tables]				
]</append>
			</behavior>
		</completion>
		<completion string="insert">
			<description>table</description>
			<behavior>
				<append>{$[data]}</append>
			</behavior>
		</completion>
		<completion string="insert">
			<description>table</description>
			<behavior>
				<append>[$[hash]]</append>
			</behavior>
		</completion>
		<completion string="join">
			<description>table</description>
			<behavior>
				<append>[$[table]]</append>
			</behavior>
		</completion>
		<completion string="join">
			<description>table</description>
			<behavior>
				<append>[$[table];
	$.offset($[int])				
	$.offset[cur]
	$.limit($[max])
	$.reverse($[true|false])
]</append>
			</behavior>
		</completion>
		<completion string="locate">
			<description>table</description>
			<behavior>
				<append>[$[field];$[value]]</append>
			</behavior>
		</completion>
		<completion string="locate">
			<description>table</description>
			<behavior>
				<append>($[expression])</append>
			</behavior>
		</completion>
		<completion string="locate">
			<description>table</description>
			<behavior>
				<append>[$[field];$[value];
	$.offset($[int])				
	$.offset[cur]
	$.limit($[max])
	$.reverse($[true|false])
]</append>
			</behavior>
		</completion>
		<completion string="locate">
			<description>table</description>
			<behavior>
				<append>($[expression])[
	$.offset($[int])				
	$.offset[cur]
	$.limit($[max])
	$.reverse($[true|false])
]</append>
			</behavior>
		</completion>
		<completion string="menu">
			<description>table</description>
			<behavior>
				<append>{
	$[]
}</append>
			</behavior>
		</completion>
		<completion string="menu">
			<description>table method, with string separator</description>
			<behavior>
				<append>{
	$[]
}[$[separator]]</append>
			</behavior>
		</completion>
		<completion string="menu">
			<description>table method, with code separator</description>
			<behavior>
				<append>{
	$[]
}{
	$[separator]
}</append>
			</behavior>
		</completion>
		<!-- foreach -->
		<completion string="offset">
			<description>table</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="line">
			<description>table</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="offset">
			<description>table</description>
			<behavior>
				<append>($[int])</append>
			</behavior>
		</completion>
		<completion string="offset">
			<description>table</description>
			<behavior>
				<append>[$[cur|set]]($[int])</append>
			</behavior>
		</completion>
		<completion string="save">
			<description>table</description>
			<behavior>
				<append>[$[path]]</append>
			</behavior>
		</completion>
		<completion string="save">
			<description>table</description>
			<behavior>
				<append>[$[path];
					$.offset($[int])				
	$.offset[cur]
	$.limit($[max])
	$.reverse($[true|false])
]</append>
			</behavior>
		</completion>
		<completion string="save">
			<description>table</description>
			<behavior>
				<append>[nameless;$[path]]</append>
			</behavior>
		</completion>
		<completion string="save">
			<description>table method, with options</description>
			<behavior>
				<append>[nameless;$[path];
	$.offset($[int])			
	$.offset[cur]
	$.limit($[max])
	$.reverse($[true|false])
]</append>
			</behavior>
		</completion>
		<completion string="save">
			<description>table</description>
			<behavior>
				<append>[append;$[path]]</append>
			</behavior>
		</completion>
		<completion string="save">
			<description>table method, with options</description>
			<behavior>
				<append>[append;$[path];
	$.offset($[int])			
	$.offset[cur]
	$.limit($[max])
	$.reverse($[true|false])
]</append>
			</behavior>
		</completion>
		<completion string="select">
			<description>table</description>
			<behavior>
				<append>($[expression])[
	$.offset($[int])
	$.offset[cur]
	$.limit($[max])
	$.reverse($[true|false])
]</append>
			</behavior>
		</completion>
		<completion string="sort">
			<description>table</description>
			<behavior>
				<append>{$[by string]}</append>
			</behavior>
		</completion>
		<completion string="sort">
			<description>table</description>
			<behavior>
				<append>{$[by string]}[$[asc|desc]]</append>
			</behavior>
		</completion>
		<completion string="sort">
			<description>table</description>
			<behavior>
				<append>($[by number])</append>
			</behavior>
		</completion>
		<completion string="sort">
			<description>table</description>
			<behavior>
				<append>($[by number])[$[asc|desc]]</append>
			</behavior>
		</completion>
	<!-- xdoc -->
		<completion string="createElement">
			<description>xdoc</description>
			<behavior>
				<append>[$[tagName]]</append>
			</behavior>
		</completion>
		<completion string="createDocumentFragment">
			<description>xdoc</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="createTextNode">
			<description>xdoc</description>
			<behavior>
				<append>[$[data]]</append>
			</behavior>
		</completion>
		<completion string="createComment">
			<description>xdoc</description>
			<behavior>
				<append>[$[data]]</append>
			</behavior>
		</completion>
		<completion string="createCDATASection">
			<description>xdoc</description>
			<behavior>
				<append>[$[data]]</append>
			</behavior>
		</completion>
		<completion string="createProcessingInstruction">
			<description>xdoc</description>
			<behavior>
				<append>[$[target];$[data]]</append>
			</behavior>
		</completion>
		<completion string="createAttribute">
			<description>xdoc</description>
			<behavior>
				<append>[$[name]]</append>
			</behavior>
		</completion>
		<completion string="createEntityReference">
			<description>xdoc</description>
			<behavior>
				<append>[$[name]]</append>
			</behavior>
		</completion>
		<completion string="getElementsByTagName">
			<description>xdoc</description>
			<behavior>
				<append>[$[tagname]]</append>
			</behavior>
		</completion>
		
		<completion string="importNode">
			<description>xdoc</description>
			<behavior>
				<append>[$[imported node]](deep)</append>
			</behavior>
		</completion>
		<completion string="createElementNS">
			<description>xdoc</description>
			<behavior>
				<append>[$[namespace url];$[qualified name]]</append>
			</behavior>
		</completion>
		<completion string="createAttributeNS">
			<description>xdoc</description>
			<behavior>
				<append>[$[namespace url];$[qualified name]]</append>
			</behavior>
		</completion>
		<completion string="getElementsByTagNameNS">
			<description>xdoc</description>
			<behavior>
				<append>[$[namespace url];$[local name]]</append>
			</behavior>
		</completion>
		<completion string="getElementById">
			<description>xdoc</description>
			<behavior>
				<append>[$[element id]]</append>
			</behavior>
		</completion>
		
		<completion string="file">
			<description>xdoc</description>
			<behavior>
				<append>[$[element id]]</append>
			</behavior>
		</completion>
		
		<completion string="save">
			<description>saving xdoc to file</description>
			<behavior>
				<append>[$[path];
	$.method[]
	$.indent[$[yes|no]] 
	$.omit-xml-declaration[$[no|yes]]
	$.charset[$[charset]]
]</append>
			</behavior>
		</completion>
	
		<completion string="string">
			<description>xdoc</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		
		<completion string="string">
			<description>converting xdoc into string</description>
			<behavior>
				<append>[
	$.method[]
	$.indent[$[yes|no]] 
	$.omit-xml-declaration[$[no|yes]]
	$.charset[$[charset]]
]</append>
			</behavior>
		</completion>
		
		<completion string="transform">
			<description>xdoc</description>
			<behavior>
				<append>[$[template]]</append>
			</behavior>
		</completion>
		<completion string="transform">
			<description>xdoc</description>
			<behavior>
				<append>[$[template]][$[xslt-parameters]]</append>
			</behavior>
		</completion>
		
<!-- xnode -->
		<completion string="insertBefore">
			<description>xnode (DOM1-interface Node)</description>
			<behavior>
				<append>[$[new child];$[ref child]]</append>
			</behavior>
		</completion>
		<completion string="replaceChild">
			<description>xnode (DOM1-interface Node)</description>
			<behavior>
				<append>[$[new child];$[old child]]</append>
			</behavior>
		</completion>
		<completion string="removeChild">
			<description>xnode (DOM1-interface Node)</description>
			<behavior>
				<append>[$[old child]]</append>
			</behavior>
		</completion>
		<completion string="appendChild">
			<description>xnode (DOM1-interface Node)</description>
			<behavior>
				<append>[$[new child]]</append>
			</behavior>
		</completion>
		<completion string="hasChildNodes">
			<description>xnode (DOM1-interface Node)</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="cloneNode">
			<description>xnode (DOM1-interface Node)</description>
			<behavior>
				<append>($[deep])</append>
			</behavior>
		</completion>
		<completion string="getAttribute">
			<description>xnode (DOM1-interface Element)</description>
			<behavior>
				<append>[$[name]]</append>
			</behavior>
		</completion>
		<completion string="setAttribute">
			<description>xnode (DOM1-interface Element)</description>
			<behavior>
				<append>[$[name];$[value]]</append>
			</behavior>
		</completion>
		<completion string="removeAttribute">
			<description>xnode (DOM1-interface Element)</description>
			<behavior>
				<append>[$[name]]</append>
			</behavior>
		</completion>
		<completion string="getAttributeNode">
			<description>xnode (DOM1-interface Element)</description>
			<behavior>
				<append>[$[name]]</append>
			</behavior>
		</completion>
		<completion string="setAttributeNode">
			<description>xnode (DOM1-interface Element)</description>
			<behavior>
				<append>[$[new attr]]</append>
			</behavior>
		</completion>
		<completion string="removeAttributeNode">
			<description>xnode (DOM1-interface Element)</description>
			<behavior>
				<append>[$[old attr]]</append>
			</behavior>
		</completion>
		<completion string="getElementsByTagName">
			<description>xnode (DOM1-interface Element)</description>
			<behavior>
				<append>[$[name]]</append>
			</behavior>
		</completion>
		<completion string="normalize">
			<description>xnode (DOM1-interface Element)</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="getAttributeNS">
			<description>xnode (DOM2-interface Element)</description>
			<behavior>
				<append>[$[namespace URI];$[local name]]</append>
			</behavior>
		</completion>
		<completion string="setAttributeNS">
			<description>xnode (DOM2-interface Element)</description>
			<behavior>
				<append>[$[namespace URI];$[qualified name];$[value]]</append>
			</behavior>
		</completion>
		<completion string="removeAttributeNS">
			<description>xnode (DOM2-interface Element)</description>
			<behavior>
				<append>[$[namespace URI];$[local name]]</append>
			</behavior>
		</completion>
		<completion string="getAttributeNodeNS">
			<description>xnode (DOM2-interface Element)</description>
			<behavior>
				<append>[$[namespace URI];$[local name]]</append>
			</behavior>
		</completion>
		<completion string="setAttributeNodeNS">
			<description>xnode (DOM2-interface Element)</description>
			<behavior>
				<append>[$[new attr]]</append>
			</behavior>
		</completion>
		<completion string="getElementsByTagNameNS">
			<description>xnode (DOM2-interface Element)</description>
			<behavior>
				<append>[$[namespace URI];$[local name]]</append>
			</behavior>
		</completion>
		<completion string="hasAttribute">
			<description>xnode (DOM2-interface Element)</description>
			<behavior>
				<append>($[name])</append>
			</behavior>
		</completion>
		<completion string="hasAttributeNS">
			<description>xnode (DOM2-interface Element)</description>
			<behavior>
				<append>($[namespace URI];$[local name])</append>
			</behavior>
		</completion>
		<completion string="hasAttributes">
			<description>xnode (DOM2-interface Element)</description>
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		
		<completion string="select">
			<description>XPath search for node</description>
			<behavior>
				<append>[$[XPath-query]]</append>
			</behavior>
		</completion>
		<completion string="selectSingle">
			<description>XPath search for single node</description>
			<behavior>
				<append>[$[XPath-query]]</append>
			</behavior>
		</completion>
		<completion string="selectString">
			<description>XPath search for a string</description>
			<behavior>
				<append>[$[XPath-query]]</append>
			</behavior>
		</completion>
		<completion string="selectNumber">
			<description>XPath search for a number</description>
			<behavior>
				<append>[$[XPath-query]]</append>
			</behavior>
		</completion>
		<completion string="selectBool">
			<description>XPath search for a boolean value</description>
			<behavior>
				<append>[$[XPath-query]]</append>
			</behavior>
		</completion>
	</set>

<!-- ^CLASSES -->

	<set name="parser3.core.classes" symbol="class">
		<completion string="cookie">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="curl">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="date">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="double">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="int">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="env">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="file">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="form">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="hash">
			<behavior>
				<append>::</append>
			</behavior>
		</completion>
		<completion string="hashfile">
			<behavior>
				<append>::</append>
			</behavior>
		</completion>
		<completion string="image">
			<behavior>
				<append>::</append>
			</behavior>
		</completion>
		<completion string="inet">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="json">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="mail">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="math">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="memcached">
			<behavior>
				<append>::</append>
			</behavior>
		</completion>
		<completion string="memory">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="reflection">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="regex">
			<behavior>
				<append>::</append>
			</behavior>
		</completion>
		<completion string="request">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="response">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="status">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="string">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="table">
			<behavior>
				<append>::</append>
			</behavior>
		</completion>
		<completion string="void">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="xdoc">
			<behavior>
				<append>::</append>
			</behavior>
		</completion>
	</set>

<!-- $CLASSES STATIC -->

	<set name="parser3.core.classes.static" symbol="class">
		<completion string="console">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="cookie">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="env">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="form">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="math">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="memcached">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="request">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="response">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="status">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
		<completion string="xdoc">
			<behavior>
				<append>:</append>
			</behavior>
		</completion>
	</set>

	<set name="parser3.sql" symbol="constant">
		<completion string="ABSOLUTE" />
		<completion string="ACTION" />
		<completion string="ADA" />
		<completion string="ADD" />
		<completion string="ALL" />
		<completion string="ALLOCATE" />
		<completion string="ALTER" />
		<completion string="AND" />
		<completion string="ANY" />
		<completion string="ARE" />
		<completion string="AS" />
		<completion string="ASC" />
		<completion string="ASSERTION" />
		<completion string="AT" />
		<completion string="AUTHORIZATION" />
		<completion string="AVG" />
		<completion string="BEGIN" />
		<completion string="BETWEEN" />
		<completion string="BIT" />
		<completion string="BIT_LENGTH" />
		<completion string="BOTH" />
		<completion string="BTREE" />
		<completion string="BY" />
		<completion string="CASCADE" />
		<completion string="CASCADED" />
		<completion string="CASE" />
		<completion string="CAST" />
		<completion string="CATALOG" />
		<completion string="CHAR" />
		<completion string="CHARACTER" />
		<completion string="CHARACTER_LENGTH" />
		<completion string="CHAR_LENGTH" />
		<completion string="CHARSET" />
		<completion string="CHECK" />
		<completion string="CLOSE" />
		<completion string="COALESCE" />
		<completion string="COLLATE" />
		<completion string="COLLATION" />
		<completion string="COLUMN" />
		<completion string="COMMIT" />
		<completion string="CONNECT" />
		<completion string="CONNECTION" />
		<completion string="CONSTRAINT" />
		<completion string="CONSTRAINTS" />
		<completion string="CONTINUE" />
		<completion string="CONVERT" />
		<completion string="CORRESPONDING" />
		<completion string="COUNT">
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="CREATE" />
		<completion string="CROSS" />
		<completion string="CURRENT" />
		<completion string="CURRENT_DATE" />
		<completion string="CURRENT_TIME" />
		<completion string="CURRENT_TIMESTAMP" />
		<completion string="CURRENT_USER" />
		<completion string="CURSOR" />
		<completion string="DATE" />
		<completion string="DAY" />
		<completion string="DEALLOCATE" />
		<completion string="DEC" />
		<completion string="DECIMAL" />
		<completion string="DECLARE" />
		<completion string="DEFAULT" />
		<completion string="DEFERRABLE" />
		<completion string="DEFERRED" />
		<completion string="DELETE" />
		<completion string="DESC" />
		<completion string="DESCRIBE" />
		<completion string="DESCRIPTOR" />
		<completion string="DIAGNOSTICS" />
		<completion string="DISCONNECT" />
		<completion string="DISTINCT" />
		<completion string="DOMAIN" />
		<completion string="DOUBLE" />
		<completion string="DROP" />
		<completion string="ELSE" />
		<completion string="END" />
		<completion string="END-EXEC" />
		<completion string="ENGINE" />
		<completion string="ESCAPE" />
		<completion string="EXCEPT" />
		<completion string="EXCEPTION" />
		<completion string="EXEC" />
		<completion string="EXECUTE" />
		<completion string="EXISTS" />
		<completion string="EXTERNAL" />
		<completion string="EXTRACT" />
		<completion string="FETCH" />
		<completion string="FIRST" />
		<completion string="FLOAT" />
		<completion string="FOR" />
		<completion string="FOREIGN" />
		<completion string="FORTRAN" />
		<completion string="FOUND" />
		<completion string="FROM" />
		<completion string="FULL" />
		<completion string="GET" />
		<completion string="GLOBAL" />
		<completion string="GO" />
		<completion string="GOTO" />
		<completion string="GRANT" />
		<completion string="GROUP" />
		<completion string="HAVING" />
		<completion string="HOUR" />
		<completion string="IDENTITY" />
		<completion string="IF" />
		<completion string="IMMEDIATE" />
		<completion string="IN" />
		<completion string="INCLUDE" />
		<completion string="INDEX" />
		<completion string="INDICATOR" />
		<completion string="INITIALLY" />
		<completion string="INNER" />
		<completion string="INPUT" />
		<completion string="INSENSITIVE" />
		<completion string="INSERT" />
		<completion string="INT" />
		<completion string="INTEGER" />
		<completion string="INTERSECT" />
		<completion string="INTERVAL" />
		<completion string="INTO" />
		<completion string="IS" />
		<completion string="ISOLATION" />
		<completion string="JOIN" />
		<completion string="KEY" />
		<completion string="LANGUAGE" />
		<completion string="LAST" />
		<completion string="LEADING" />
		<completion string="LEFT">
			<behavior>
				<append>($[string], $[length])</append>
			</behavior>
		</completion>
		<completion string="LEVEL" />
		<completion string="LIKE" />
		<completion string="LOCAL" />
		<completion string="LOCK" />
		<completion string="LOWER">
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="MATCH" />
		<completion string="MAX" />
		<completion string="MIN" />
		<completion string="MINUTE" />
		<completion string="MODULE" />
		<completion string="MONTH" />
		<completion string="NAMES" />
		<completion string="NATIONAL" />
		<completion string="NATURAL" />
		<completion string="NCHAR" />
		<completion string="NEXT" />
		<completion string="NO" />
		<completion string="NONE" />
		<completion string="NOT" />
		<completion string="NOW">
			<behavior>
				<append>()</append>
			</behavior>
		</completion>
		<completion string="NULLIF" />
		<completion string="NUMERIC" />
		<completion string="OCTET_LENGTH" />
		<completion string="OF" />
		<completion string="ON" />
		<completion string="ONLY" />
		<completion string="OPEN" />
		<completion string="OPTION" />
		<completion string="OR" />
		<completion string="ORDER" />
		<completion string="OUTER" />
		<completion string="OUTPUT" />
		<completion string="OVERLAPS" />
		<completion string="PAD" />
		<completion string="PARTIAL" />
		<completion string="PASCAL" />
		<completion string="POSITION" />
		<completion string="PRECISION" />
		<completion string="PREPARE" />
		<completion string="PRESERVE" />
		<completion string="PRIMARY" />
		<completion string="PRIOR" />
		<completion string="PRIVILEGES" />
		<completion string="PROCEDURE" />
		<completion string="PUBLIC" />
		<completion string="READ" />
		<completion string="REAL" />
		<completion string="REFERENCES" />
		<completion string="RELATIVE" />
		<completion string="RESTRICT" />
		<completion string="REVOKE" />
		<completion string="RIGHT">
			<behavior>
				<append>($[string], $[length])</append>
			</behavior>
		</completion>
		<completion string="ROLLBACK" />
		<completion string="ROWS" />
		<completion string="SCHEMA" />
		<completion string="SCROLL" />
		<completion string="SECOND" />
		<completion string="SECTION" />
		<completion string="SELECT" />
		<completion string="SESSION" />
		<completion string="SESSION_USER" />
		<completion string="SET" />
		<completion string="SIZE" />
		<completion string="SMALLINT" />
		<completion string="SOME" />
		<completion string="SPACE" />
		<completion string="SQL" />
		<completion string="SQLCA" />
		<completion string="SQLCODE" />
		<completion string="SQLERROR" />
		<completion string="SQLSTATE" />
		<completion string="SQLWARNING" />
		<completion string="SUBSTRING" />
		<completion string="SUM">
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="SYSTEM_USER" />
		<completion string="TABLE" />
		<completion string="TABLES" />
		<completion string="TEMPORARY" />
		<completion string="THEN" />
		<completion string="TIME" />
		<completion string="TIMESTAMP" />
		<completion string="TIMEZONE_HOUR" />
		<completion string="TIMEZONE_MINUTE" />
		<completion string="TO" />
		<completion string="TRAILING" />
		<completion string="TRANSACTION" />
		<completion string="TRANSLATE" />
		<completion string="TRUNCATE" />
		<completion string="TRANSLATION" />
		<completion string="TRIM">
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="UNION" />
		<completion string="UNIQUE" />
		<completion string="UNKNOWN" />
		<completion string="UNLOCK" />
		<completion string="UPDATE" />
		<completion string="UPPER">
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="USAGE" />
		<completion string="USER" />
		<completion string="USING" />
		<completion string="VALUE" />
		<completion string="VALUES" />
		<completion string="VARCHAR" />
		<completion string="VARYING" />
		<completion string="VIEW" />
		<completion string="WHEN" />
		<completion string="WHENEVER" />
		<completion string="WHERE" />
		<completion string="WITH" />
		<completion string="WORK" />
		<completion string="WRITE" />
		<completion string="YEAR" />
		<completion string="ZONE" />
	</set>
	
	<set name="parser3.sql.types" symbol="constant">
		<completion string="bigint" />
		<completion string="bigserial" />
		<completion string="bit" />
		<completion string="bit varying" />
		<completion string="bool" />
		<completion string="boolean" />
		<completion string="box" />
		<completion string="bytea" />
		<completion string="char" />
		<completion string="character" />
		<completion string="character varying" />
		<completion string="cidr" />
		<completion string="circle" />
		<completion string="date" />
		<completion string="datetime" />
		<completion string="double precision" />
		<completion string="float" />
		<completion string="float8" />
		<completion string="hstore" />
		<completion string="inet" />
		<completion string="int" />
		<completion string="int4" />
		<completion string="int8" />
		<completion string="integer" />
		<completion string="interval" />
		<completion string="json" />
		<completion string="jsonb" />
		<completion string="line" />
		<completion string="lseg" />
		<completion string="macaddr" />
		<completion string="money" />
		<completion string="numeric" />
		<completion string="path" />
		<completion string="pg_lsn" />
		<completion string="point" />
		<completion string="polygon" />
		<completion string="real" />
		<completion string="serial" />
		<completion string="serial8" />
		<completion string="smallint" />
		<completion string="smallserial" />
		<completion string="text" />
		<completion string="time" />
		<completion string="timestamp" />
		<completion string="timestampz" />
		<completion string="tinyint" />
		<completion string="tsquery" />
		<completion string="tsvector" />
		<completion string="txid_snapshot" />
		<completion string="uuid" />
		<completion string="xml" />
		<completion string="unsigned" />
		<completion string="varchar" />
	</set>
	
<!-- CORE -->

<!-- ^DATE -->
	
	<set name="parser3.core.date" symbol="method">
		<completion string=":create">
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string=":now">
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string=":now">
			<behavior>
				<append>[$[roll]]</append>
			</behavior>
		</completion>
		<completion string=":today">
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string=":unix-timestamp">
			<behavior>
				<append>($[timestamp])</append>
			</behavior>
		</completion>
		<completion string="calendar">
			<behavior>
				<append>[$[rus|eng]]($[year];$[month])</append>
			</behavior>
		</completion>
		<completion string="calendar">
			<behavior>
				<append>[$[rus|eng]]($[year];$[month];$[day])</append>
			</behavior>
		</completion>
		<completion string="last-day">
			<behavior>
				<append>($[year];$[month])</append>
			</behavior>
		</completion>
		<completion string="roll">
			<behavior>
				<append>[TZ][$[default timezone]]</append>
			</behavior>
		</completion>
	</set>

<!-- ^DOUBLE -->
	
	<set name="parser3.core.double"  symbol="method">
		<completion string="sql">
			<behavior>
				<append>{
	$[sql]
}</append>
			</behavior>
		</completion>
		<completion string="sql">
			<behavior>
				<append>{
	$[sql]
}[
	$.limit(1)
	$.offset($[value])
	$.default{$[code]}
	$.default($[expression])
]</append>
			</behavior>
		</completion>
	</set>

<!-- ^INT -->
	
	<set name="parser3.core.int" symbol="method">
		<completion string="sql">
			<behavior>
				<append>{
	$[sql]
}</append>
			</behavior>
		</completion>
		<completion string="sql">
			<behavior>
				<append>{
	$[sql]
}[
	$.limit(1)
	$.offset($[value])
	$.default{$[code]}
	$.default($[expression])
]</append>
			</behavior>
		</completion>
	</set>

<!-- $ENV -->
	
	<set name="parser3.core.env" symbol="property">
		<completion string="fields"  />
		
		<completion string="PARSER_VERSION" />
		<completion string="REMOTE_ADDR" />
		<completion string="HTTP_USER_AGENT" />
		<completion string="HTTP_">
			<behavior>
				<append>$[]</append>
			</behavior>
		</completion>
	</set>
	
	<set name="parser3.core.env.method" symbol="property">
		<completion string="fields">
			<behavior>
				<append>.</append>
			</behavior>
		</completion>
	</set>

<!-- CONSOLE -->

	<set name="parser3.core.console.static" >
		<completion string="line" symbol="property"/>
		<completion string="line" symbol="method">
			<behavior>
				<append>[$[text]]</append>
			</behavior>
		</completion>
	</set>

<!-- COOKIE -->

	<set name="parser3.core.cookie" symbol="property">
		<completion string="fields" />
	</set>
	
	<set name="parser3.core.cookie.static" symbol="property">
		<completion string="fields">
			<behavior>
				<append>.</append>
			</behavior>
		</completion>
	</set>

<!-- CURL -->

	<set name="parser3.core.curl"  symbol="method">
<!-- info -->	
		<completion string="info">
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="info">
			<behavior>
				<append>[$[name]]</append>
			</behavior>
		</completion>
		
<!-- load -->	
		<completion string="load">
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="load">
			<behavior>
				<append>[$[options]]</append>
			</behavior>
		</completion>
<!-- options -->	
		<completion string="options">
			<behavior>
				<append>[$[options]]</append>
			</behavior>
		</completion>
<!-- session -->	
		<completion string="session">
			<behavior>
				<append>{$[code]}</append>
			</behavior>
		</completion>
<!-- version -->	
		<completion string="version">
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
	</set>

<!-- FILE -->
	
	<set name="parser3.core.file" symbol="method">

		<completion string=":base64">
			<behavior>
				<append>[$[text]]</append>
			</behavior>
		</completion>
		
		<completion string=":base64">
			<behavior>
				<append>[$[text|binary];$[filename];$[text];
	$.content-type[$[type]]
]</append>
			</behavior>
		</completion>
		
		<completion string=":cgi">
			<behavior>
				<append>[$[filename]]</append>
			</behavior>
		</completion>
		
		<completion string=":cgi">
			<behavior>
				<append>[$[filename];$[env hash]]</append>
			</behavior>
		</completion>
		
		<completion string=":cgi">
			<behavior>
				<append>[$[format];$[filename];$[env hash];$[arguments]]</append>
			</behavior>
		</completion>
		
		<completion string=":exec">
			<behavior>
				<append>[$[filename]]</append>
			</behavior>
		</completion>
		
		<completion string=":exec">
			<behavior>
				<append>[$[filename];$[env hash]]</append>
			</behavior>
		</completion>
		
		<completion string=":exec">
			<behavior>
				<append>[$[text|binary];$[filename];$[env hash];$[arguments]]</append>
			</behavior>
		</completion>
		
		<completion string=":create">
			<behavior>
				<append>[$[text|binary];$[filename];$[text]]</append>
			</behavior>
		</completion>
		
		<completion string=":create">
			<behavior>
				<append>[$[text|binary];$[filename];$[text];
	$.from-charset[$[from charset]]
	$.to-charset[$[to charset]]
	$.content-type[$[type]]
]</append>
			</behavior>
		</completion>
		
		<completion string=":create">
			<behavior>
				<append>[$[text];
	$.from-charset[$[from charset]]
	$.to-charset[$[to charset]]
	$.content-type[$[type]]
	$.name[$[filename]]
	$.mode[$[text|binary]]
]</append>
			</behavior>
		</completion>
		
		<completion string=":create">
			<behavior>
				<append>[$[file];
	$.from-charset[$[from charset]]
	$.to-charset[$[to charset]]
	$.content-type[$[type]]
	$.name[$[filename]]
	$.mode[$[text|binary]]
]</append>
			</behavior>
		</completion>
		
		<completion string=":load">
			<behavior>
				<append>[$[text|binary];$[filename]]</append>
			</behavior>
		</completion>
		
		<completion string=":load">
			<behavior>
				<append>[$[text|binary];$[filename];$[options]]</append>
			</behavior>
		</completion>
		
		<completion string=":load">
			<behavior>
				<append>[$[text|binary];$[filename];$[new filename]]</append>
			</behavior>
		</completion>
		
		<completion string=":load">
			<behavior>
				<append>[$[text|binary];$[filename];$[new filename];$[options]]</append>
			</behavior>
		</completion>
		
		<completion string=":sql">
			<behavior>
				<append>{
	$[sql]
}</append>
			</behavior>
		</completion>
		
		<completion string=":sql">
			<behavior>
				<append>{
	$[sql]
}[
	$.name[$[filename]]
	$.content-type[$[type]]
	$.limit(1)
	$.offset($[value])
]</append>
			</behavior>
		</completion>
		
		<completion string=":stat">
			<behavior>
				<append>[$[filename]]</append>
			</behavior>
		</completion>

<!-- static methods -->
		<completion string="base64">
			<behavior>
				<append>[$[filename]]</append>
			</behavior>
		</completion>		
		<completion string="basename">
			<behavior>
				<append>[$[path]]</append>
			</behavior>
		</completion>		
		<completion string="copy">
			<behavior>
				<append>[$[from];$[to]]</append>
			</behavior>
		</completion>		
		<completion string="crc32">
			<behavior>
				<append>[$[filename]]</append>
			</behavior>
		</completion>		
		<completion string="delete">
			<behavior>
				<append>[$[path];
	$.keep-empty-dirs(true)
	$.exception(false)
]</append>
			</behavior>
		</completion>		
		<completion string="dirname">
			<behavior>
				<append>[$[path]]</append>
			</behavior>
		</completion>		
		<completion string="find">
			<behavior>
				<append>[$[path]]{
	$[code]
}</append>
			</behavior>
		</completion>		
		<completion string="fullpath">
			<behavior>
				<append>[$[filename]]</append>
			</behavior>
		</completion>		
		<completion string="justext">
			<behavior>
				<append>[$[path]]</append>
			</behavior>
		</completion>		
		<completion string="justname">
			<behavior>
				<append>[$[path]]</append>
			</behavior>
		</completion>		
		<completion string="list">
			<behavior>
				<append>[$[path]]</append>
			</behavior>
		</completion>		
		<completion string="list">
			<behavior>
				<append>[$[path];$[regexp filter]]</append>
			</behavior>
		</completion>		
		<completion string="list">
			<behavior>
				<append>[$[path];
	$.filter[$[regexp]]
	$.stat($[true|false])
]</append>
			</behavior>
		</completion>		
		<completion string="lock">
			<behavior>
				<append>[$[lockfile]]{
	$[code]
}</append>
			</behavior>
		</completion>
		<completion string="md5">
			<behavior>
				<append>[$[filename]]</append>
			</behavior>
		</completion>		
		<completion string="move">
			<behavior>
				<append>[$[from];$[to]]</append>
			</behavior>
		</completion>		
		<completion string="move">
			<behavior>
				<append>[$[from];$[to];
	$.keep-empty-dirs(true)
]</append>
			</behavior>
		</completion>		
	</set>

<!-- FORM -->
	
	<set name="parser3.core.form" symbol="property">
		<completion string="fields" />
		<completion string="files" />
		<completion string="imap" />
		<completion string="qtail" />
		<completion string="tables" />
	</set>
	
	<set name="parser3.core.form.static" symbol="property">
		<completion string="fields">
			<behavior>
				<append>.</append>
			</behavior>
		</completion>
		<completion string="files">
			<behavior>
				<append>.</append>
			</behavior>
		</completion>
	</set>
	
<!-- HASH -->

	<set name="parser3.core.hash" symbol="method">
		<completion string="create">
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="sql">
			<behavior>
				<append>{
	$[sql]
}</append>
			</behavior>
		</completion>
		<completion string="sql">
			<behavior>
				<append>{
	$[sql]
}[
	$.limit($[limit])
	$.offset($[offset])
	$.distinct($[true|false])
	$.bind[$[variables hash]]
	$.type[$[hash|string|table]]
]</append>
			</behavior>
		</completion>
	</set>

<!-- HASHFILE -->

	<set name="parser3.core.hashfile" symbol="method">
		<completion string="open">
			<behavior>
				<append>[$[file]]</append>
			</behavior>
		</completion>
	</set>

<!-- IMAGE -->

	<set name="parser3.core.image" symbol="method">
		<completion string="create">
			<behavior>
				<append>($[x];$[y])</append>
			</behavior>
		</completion>
		<completion string="create">
			<behavior>
				<append>($[x];$[y];$[color])</append>
			</behavior>
		</completion>
		<completion string="load">
			<behavior>
				<append>[$[file]]</append>
			</behavior>
		</completion>
		<completion string="measure">
			<behavior>
				<append>[$[file]]</append>
			</behavior>
		</completion>
	</set>

<!-- INET -->
	
	<set name="parser3.core.inet" symbol="method">
		<completion string="aton">
			<behavior>
				<append>[$[ip string]]</append>
			</behavior>
		</completion>
		<completion string="ip2name">
			<behavior>
				<append>[$[ip]]</append>
			</behavior>
		</completion>
		<completion string="ip2name">
			<behavior>
				<append>[$[ip];
	$.ipv[$[4|6|any]]
]</append>
			</behavior>
		</completion>
		<completion string="name2ip">
			<behavior>
				<append>[$[domain]]</append>
			</behavior>
		</completion>
		<completion string="name2ip">
			<behavior>
				<append>[$[domain];
	$.ipv[$[4|6|any]]
	$.table($[true|false])				
]</append>
			</behavior>
		</completion>
		<completion string="ntoa">
			<behavior>
				<append>[$[ip number]]</append>
			</behavior>
		</completion>
	</set>

<!-- JSON -->
	
	<set name="parser3.core.json" symbol="method">
		<completion string="parse">
			<behavior>
				<append>[$[json string];]</append>
			</behavior>
		</completion>
		<completion string="parse">
			<behavior>
				<append>[$[json string];
	$.depth($[depth])
	$.double($[true|false])
	$.int($[true|false])
	$.distinct[$[first|last|all]]
	$.object[$[object method]]
	$.array[$[array method]]
	$.taint[$[taint method]]
]</append>
			</behavior>
		</completion>
		<completion string="string">
			<behavior>
				<append>[$[json];]</append>
			</behavior>
		</completion>
		<completion string="string">
			<behavior>
				<append>[$[json];
	$.skip-unknown($[true|false])
	$.indent($[true|false])
	$.date[$[sql-string|gmt-string|iso-string|unix-timestamp]]
	$.void[$[null|string]]
	$.table[object|array|compact]
	$.file[text|base64|stat]
	$.xdoc[$[params]]
	$._default[$[method]]
]</append>
			</behavior>
		</completion>
	</set>

<!-- MAIL -->
	
	<set name="parser3.core.mail" symbol="method">
		<completion string="send">
			<behavior>
				<append>[
	$.from[$[from]]
	$.to[$[to]]
	$.subject[$[subject]]
	$.text[$[text]]
]</append>
			</behavior>
		</completion>
	</set>

<!-- MATH -->
	
	<set name="parser3.core.math" symbol="method">
		<completion string="abs">
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="sign">
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="convert">
			<behavior>
				<append>[$[]]($[from];$[to])</append>
			</behavior>
		</completion>
		<completion string="crc32">
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="crypt">
			<behavior>
				<append>[$[password];$[salt]]</append>
			</behavior>
		</completion>
		<completion string="degrees">
			<behavior>
				<append>($[radians])</append>
			</behavior>
		</completion>
		<completion string="radians">
			<behavior>
				<append>($[degrees])</append>
			</behavior>
		</completion>
		<completion string="digest">
			<behavior>
				<append>[$[algorithm];$[string ot file];
	$.format[$[hex|base64]]
	$.hmac[$[key]]
]</append>
			</behavior>
		</completion>
		<completion string="exp">
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="log">
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="log10">
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="md5">
			<behavior>
				<append>[$[string]]</append>
			</behavior>
		</completion>
		<completion string="pow">
			<behavior>
				<append>[$[number];$[degree]]</append>
			</behavior>
		</completion>
		<completion string="random">
			<behavior>
				<append>($[max])</append>
			</behavior>
		</completion>
		<completion string="round">
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="floor">
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="ceiling">
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="sha1">
			<behavior>
				<append>[$[]]</append>
			</behavior>
		</completion>
		<completion string="sin">
			<behavior>
				<append>($[radians])</append>
			</behavior>
		</completion>
		<completion string="asin">
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="cos">
			<behavior>
				<append>($[radians])</append>
			</behavior>
		</completion>
		<completion string="acos">
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="tan">
			<behavior>
				<append>($[radians])</append>
			</behavior>
		</completion>
		<completion string="atan">
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="sqrt">
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="trunc">
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="frac">
			<behavior>
				<append>($[])</append>
			</behavior>
		</completion>
		<completion string="uid64">
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="uuid">
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
	</set>
			
	<set name="parser3.core.math.static" symbol="property">
		<completion string="PI" />
		<completion string="E" />
	</set>


<!-- MEMCACHED -->
	
	<set name="parser3.core.memcached" symbol="method">
		<completion string="open">
			<behavior>
				<append>[$[server1:port1,server2]]</append>
			</behavior>
		</completion>
		<completion string="open">
			<behavior>
				<append>[$[server1:port1,server2]]($[time])</append>
			</behavior>
		</completion>
		<completion string="open">
			<behavior>
				<append>[
	$.server[$[server1:port1]] 
	$.binary-protocol($[true|false])
	$.connect-timeout($[timeout]) 
]</append>
			</behavior>
		</completion>
	</set>


<!-- MEMORY -->
	
	<set name="parser3.core.memory" symbol="method">
		<completion string="compact">
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
	</set>

<!-- REFLECTION -->
	
	<set name="parser3.core.reflection" symbol="method">
		<completion string="base">
			<behavior>
				<append>[$[class or object]]</append>
			</behavior>
		</completion>
		<completion string="base_name">
			<behavior>
				<append>[$[class or object]]</append>
			</behavior>
		</completion>
		<completion string="class">
			<behavior>
				<append>[$[object]]</append>
			</behavior>
		</completion>
		<completion string="class_by_name">
			<behavior>
				<append>[$[classname]]</append>
			</behavior>
		</completion>
		<completion string="class_name">
			<behavior>
				<append>[$[object]]</append>
			</behavior>
		</completion>
		<completion string="classes">
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="copy">
			<behavior>
				<append>[$[from];$[to]]</append>
			</behavior>
		</completion>
		<completion string="create">
			<behavior>
				<append>[$[classname];$[constructor name];$[params]]</append>
			</behavior>
		</completion>
		<completion string="create">
			<behavior>
				<append>[
	$.class[$[classname]]
	$.constructor[$[constructor name]]
	$.arguments[
		$.1[]
		$.2[]
		$.3[]
	]
]</append>
			</behavior>
		</completion>
		<completion string="def">
			<behavior>
				<append>[class;$[classname]]</append>
			</behavior>
		</completion>
		<completion string="delete">
			<behavior>
				<append>[$[object];$[fieldname]]</append>
			</behavior>
		</completion>
		<completion string="delete">
			<behavior>
				<append>[$[class];$[fieldname]]</append>
			</behavior>
		</completion>
		<completion string="dynamical">
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="dynamical">
			<behavior>
				<append>[$[class or object]]</append>
			</behavior>
		</completion>
		<completion string="field">
			<behavior>
				<append>[$[object];$[fieldname]]</append>
			</behavior>
		</completion>
		<completion string="field">
			<behavior>
				<append>[$[class];$[fieldname]]</append>
			</behavior>
		</completion>
		<completion string="fields">
			<behavior>
				<append>[$[class]]</append>
			</behavior>
		</completion>
		<completion string="fields">
			<behavior>
				<append>[$[object]]</append>
			</behavior>
		</completion>
		<completion string="fields_reference">
			<behavior>
				<append>[$[object]]</append>
			</behavior>
		</completion>
		<completion string="filename">
			<behavior>
				<append>[$[object or class or method]]</append>
			</behavior>
		</completion>
		<completion string="is">
			<behavior>
				<append>[$[element];$[type]]</append>
			</behavior>
		</completion>
		<completion string="is">
			<behavior>
				<append>[$[element];$[type];$[context]]</append>
			</behavior>
		</completion>
		<completion string="method">
			<behavior>
				<append>[$[object];$[fieldname]]</append>
			</behavior>
		</completion>
		<completion string="method">
			<behavior>
				<append>[$[class];$[fieldname]]</append>
			</behavior>
		</completion>
		<completion string="method_info">
			<behavior>
				<append>[$[classname];$[methodname]]</append>
			</behavior>
		</completion>
		<completion string="method_info">
			<behavior>
				<append>[$[method]]</append>
			</behavior>
		</completion>
		<completion string="methods">
			<behavior>
				<append>[$[classname]]</append>
			</behavior>
		</completion>
		<completion string="methods">
			<behavior>
				<append>[$[classname];
	$.reverse($[true|false])
]</append>
			</behavior>
		</completion>
		<completion string="mixin">
			<behavior>
				<append>[$[source];
	$.to[]
	$.name[]
	$.methods($[true|false])
	$.fields($[true|false])
	$.overwrite($[false|true])
]</append>
			</behavior>
		</completion>
		<completion string="stack">
			<behavior>
				<append>[
	$.args($[false|true])				
	$.locals($[true|false])
	$.limit()
	$.offset()
]</append>
			</behavior>
		</completion>
		<completion string="tainting">
			<behavior>
				<append>[$[string]]</append>
			</behavior>
		</completion>
		<completion string="tainting">
			<behavior>
				<append>[$[type];$[string]]</append>
			</behavior>
		</completion>
		<completion string="uid">
			<behavior>
				<append>[$[object]]</append>
			</behavior>
		</completion>
	</set>

<!-- REGEX -->

	<set name="parser3.core.regex" symbol="method">
		<completion string="create">
			<behavior>
				<append>[$[pattern]]</append>
			</behavior>
		</completion>
		<completion string="create">
			<behavior>
				<append>[$[pattern]][$[options]]</append>
			</behavior>
		</completion>
	</set>

<!-- REQUEST -->

	<set name="parser3.core.request" symbol="property">
		<completion string="argv">
			<behavior>
				<append>.</append>
			</behavior>
		</completion>
		<completion string="body">
			<behavior>
				<append>.</append>
			</behavior>
		</completion>
		<completion string="post-charset">
			<behavior>
				<append>.</append>
			</behavior>
		</completion>
		<completion string="body-charset">
			<behavior>
				<append>.</append>
			</behavior>
		</completion>
		<completion string="post-body">
			<behavior>
				<append>.</append>
			</behavior>
		</completion>
		<completion string="body-file">
			<behavior>
				<append>.</append>
			</behavior>
		</completion>
		<completion string="headers">
			<behavior>
				<append>.</append>
			</behavior>
		</completion>
		<completion string="method">
			<behavior>
				<append>.</append>
			</behavior>
		</completion>
		<completion string="query">
			<behavior>
				<append>.</append>
			</behavior>
		</completion>
		<completion string="uri">
			<behavior>
				<append>.</append>
			</behavior>
		</completion>
	</set>
	
	<set name="parser3.core.request.static" symbol="property">
		<completion string="argv" />
		<completion string="body" />
		<completion string="post-charset" />
		<completion string="body-charset" />
		<completion string="post-body" />
		<completion string="body-file" />
		<completion string="headers" />
		<completion string="method" />
		<completion string="query" />
		<completion string="uri" />
		<completion string="charset">
			<behavior>
				<append>[$[charset]]</append>
			</behavior>
		</completion>
		<completion string="document-root">
			<behavior>
				<append>[$[path]]</append>
			</behavior>
		</completion>
	</set>
	
<!-- RESPONSE -->

	<set name="parser3.core.response" >
		<completion string="clear" symbol="method">
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="headers" symbol="property">
			<behavior>
				<append>.</append>
			</behavior>
		</completion>
	</set>
	
	<set name="parser3.core.response.static" symbol="property">
		<completion string="status" />
		<completion string="headers" />
		<completion string="body">
			<behavior>
				<append>[$[data]]</append>
			</behavior>
		</completion>
		<completion string="charset">
			<behavior>
				<append>[$[charset]]</append>
			</behavior>
		</completion>
		<completion string="download">
			<behavior>
				<append>[$[data]]</append>
			</behavior>
		</completion>
		<completion string="location">
			<behavior>
				<append>[$[uri]]</append>
			</behavior>
		</completion>
		<completion string="refresh">
			<behavior>
				<append>[
	$.value(0)
	$.url[$[uri]]
]</append>
			</behavior>
		</completion>
	</set>

<!-- STATUS -->
	
	<set name="parser3.core.status" symbol="property">
		<completion string="memory">
			<behavior>
				<append>.</append>
			</behavior>
		</completion>
		<completion string="pid">
			<behavior>
				<append>.</append>
			</behavior>
		</completion>
		<completion string="rusage">
			<behavior>
				<append>.</append>
			</behavior>
		</completion>
		<completion string="tid">
			<behavior>
				<append>.</append>
			</behavior>
		</completion>
	</set>
	<set name="parser3.core.status.static" symbol="property">
		<completion string="memory" />
		<completion string="pid" />
		<completion string="rusage" />
		<completion string="tid" />
	</set>
	
<!-- STRING -->

	<set name="parser3.core.string" symbol="method">

		<completion string="base64">
			<behavior>
				<append>[$[string]]</append>
			</behavior>
		</completion>
		<completion string="base64">
			<behavior>
				<append>[$[string];$.strict(true)]</append>
			</behavior>
		</completion>
		<completion string="idna">
			<behavior>
				<append>[$[string]]</append>
			</behavior>
		</completion>
		<completion string="js-unescape">
			<behavior>
				<append>[$[string]]</append>
			</behavior>
		</completion>
		<completion string="sql">
			<behavior>
				<append>{
	$[sql]
}</append>
			</behavior>
		</completion>
		<completion string="sql">
			<behavior>
				<append>{
	$[sql]
}[
	$.limit(1)
	$.offset($[offset count])
	$.default{$[code]}
	$.default[$[string]]
	$.default($[expression])
	$.bind[$[variables hash]]
]</append>
			</behavior>
		</completion>
		<completion string="unescape">
			<behavior>
				<append>[$[js or uri];$[string]] </append>
			</behavior>
		</completion>
		<completion string="unescape">
			<behavior>
				<append>[$[js or uri];$[string];
	$.charset[$[charset]]
] </append>
			</behavior>
		</completion>
	</set>


<!-- TABLE -->

	<set name="parser3.core.table" symbol="method">

<!-- table::create -->
		<completion string="create">
			<behavior>
				<append>{$[data]}</append>
			</behavior>
		</completion>

		<completion string="create">
			<behavior>
				<append>[nameless]{$[data]}</append>
			</behavior>
		</completion>

		<completion string="create">
			<behavior>
				<append>{
	$[data]
}[
	$.separator[$[separator symbol]]
	$.encloser[$[encloser symbol]]
]</append>
			</behavior>
		</completion>

		<completion string="create">
			<behavior>
				<append>[$[table]]</append>
			</behavior>
		</completion>

		<completion string="create">
			<behavior>
				<append>[$[table];
	$.offset($[count])
	$.offset[cur]
	$.limit($[maximum])
	$.reverse($[true/false])
]</append>
			</behavior>
		</completion>

<!-- table::load -->

		<completion string="load">
			<behavior>
				<append>[$[file]]</append>
			</behavior>
		</completion>
		<completion string="load">
			<behavior>
				<append>[$[file];
	$.separator[$[separator symbol]]
	$.encloser[$[encloser symbol]]
]</append>
			</behavior>
		</completion>
		<completion string="load">
			<behavior>
				<append>[nameless;$[file]]</append>
			</behavior>
		</completion>
		<completion string="load">
			<behavior>
				<append>[nameless;$[file];
	$.separator[$[separator symbol]]
	$.encloser[$[encloser symbol]]
]</append>
			</behavior>
		</completion>

<!-- table::sql -->
		<completion string="sql">
			<behavior>
				<append>{
	$[sql]
}</append>
			</behavior>
		</completion>
		<completion string="sql">
			<behavior>
				<append>{
	$[sql]
}[
	$.limit($[limit count])
	$.offset($[offset count])
	$.bind[$[variables hash]]
]</append>
			</behavior>
		</completion>
	</set>
	
<!-- TAINT -->

	<set name="parser3.core.taint.transformation-type" symbol="property">
		<completion string="as-is" />
		<completion string="file-spec" />
		<completion string="uri" />
		<completion string="http-header" />
		<completion string="mail-header" />
		<completion string="sql" />
		<completion string="js" />
		<completion string="json" />
		<completion string="parser-code" />
		<completion string="regex" />
		<completion string="xml" />
		<completion string="html" />
		<completion string="optimized-as-is" />
		<completion string="optimized-xml" />
		<completion string="optimized-html" />
	</set>

<!-- VOID -->
	
	<set name="parser3.core.void" symbol="method">
		<completion string="sql">
			<behavior>
				<append>{
	$[sql]
}</append>
			</behavior>
		</completion>
		<completion string="sql">
			<behavior>
				<append>{
	$[sql]
}[
	$.bind[$[variables hash]]
]</append>
			</behavior>
		</completion>
	</set>


<!-- XDOC -->
	
	<set name="parser3.core.xdoc" symbol="method">
		<completion string="create">
			<description>Creating a document based on specified XML</description>
			<behavior>
				<append>{$[xml]}</append>
			</behavior>
		</completion>
		<completion string="create">
			<description>Creating a document based on specified XML</description>
			<behavior>
				<append>[$[basepath]]{$[xml]}</append>
			</behavior>
		</completion>
		<completion string="create">
			<description>Creating a new empty document</description>
			<behavior>
				<append>[$[tagname]]</append>
			</behavior>
		</completion>
		<completion string="create">
			<description>Creating a new empty document</description>
			<behavior>
				<append>[$[basepath];$[tagname]]</append>
			</behavior>
		</completion>
		<completion string="create">
			<description>Creating a document based on specified file</description>
			<behavior>
				<append>[$[file]]</append>
			</behavior>
		</completion>
		<completion string="load">
			<description>Loading XML from disk or HTTP-server or other source</description>
			<behavior>
				<append>[$[filename]]</append>
			</behavior>
		</completion>
	</set>
	
	
	<set name="parser3.core.xdoc.constant" symbol="constant">
		<completion string="ELEMENT_NODE"><description>1</description></completion>
		<completion string="ATTRIBUTE_NODE"><description>2</description></completion>
		<completion string="TEXT_NODE"><description>3</description></completion>
		<completion string="CDATA_SECTION_NODE"><description>4</description></completion>
		<completion string="ENTITY_REFERENCE_NODE"><description>5</description></completion>
		<completion string="ENTITY_NODE"><description>6</description></completion>
		<completion string="PROCESSING_INSTRUCTION_NODE"><description>7</description></completion>
		<completion string="COMMENT_NODE"><description>8</description></completion>
		<completion string="DOCUMENT_NODE"><description>9</description></completion>
		<completion string="DOCUMENT_TYPE_NODE"><description>10</description></completion>
		<completion string="DOCUMENT_FRAGMENT_NODE"><description>11</description></completion>
		<completion string="NOTATION_NODE"><description>12</description></completion>
	</set>
	
<!-- CORE OPERATORS -->

	<set name="parser3.core.methods" symbol="function">
<!-- A -->
		<completion string="apply-taint">
			<behavior>
				<append>[$[text]]</append>
			</behavior>
		</completion>
		<completion string="apply-taint">
			<behavior>
				<append>[$[type of transformation]][$[text]]</append>
			</behavior>
		</completion>
<!-- B -->
		<completion string="break">
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="break">
			<behavior>
				<append>($[condition])</append>
			</behavior>
		</completion>
<!-- C -->
		<completion string="cache">
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="cache">
			<behavior>
				<append>[$[file or date]]</append>
			</behavior>
		</completion>
		<completion string="cache">
			<behavior>
				<append>($[seconds])</append>
			</behavior>
		</completion>
		<completion string="cache">
			<behavior>
				<append>[$[file]]($[seconds])</append>
			</behavior>
		</completion>
		<completion string="cache">
			<behavior>
				<append>[$[file]]($[seconds]){$[code]}</append>
			</behavior>
		</completion>
		<completion string="cache">
			<behavior>
				<append>[$[file]]($[seconds]){$[code]}{$[exception handled]}</append>
			</behavior>
		</completion>
		<completion string="cache">
			<behavior>
				<append>[$[file]][$[date]]{$[code]}</append>
			</behavior>
		</completion>
		<completion string="cache">
			<behavior>
				<append>[$[file]][$[date]]{$[code]}{$[exception handled]}</append>
			</behavior>
		</completion>
	   
		<completion string="case">
			<description>string to compare</description>
			<behavior>
				<append>[$[string]]{
	$[code]
}</append>
			</behavior>
		</completion>
		<completion string="case">
			<description>mathematical expression</description>
			<behavior>
				<append>($[expression]){
	$[code]
}</append>
			</behavior>
		</completion>
		<completion string="case">
			<behavior>
				<append>[DEFAULT]{
	$[]
}</append>
			</behavior>
		</completion>
		
		<completion string="connect">
			<behavior>
				<append>[$[connection string]]{
	$[code]
}</append>
			</behavior>
		</completion>
		
		<completion string="continue">
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="continue">
			<behavior>
				<append>($[condition])</append>
			</behavior>
		</completion>
<!-- D -->
<!-- E -->
		<completion string="eval">
			<behavior>
				<append>($[expression])</append>
			</behavior>
		</completion>
		<completion string="eval">
			<behavior>
				<append>($[expression])[$[format string]]</append>
			</behavior>
		</completion>
<!-- F -->
		<completion string="for">
			<behavior>
				<append>[$[counter]]($[from];$[to]){
	$[code]
}</append>
			</behavior>
		</completion>
		<completion string="for">
			<description>with string delimiter</description>
			<behavior>
				<append>[$[counter]]($[from];$[to]){
	$[code]
}[$[string delimiter]]</append>
			</behavior>
		</completion>
		<completion string="for">
			<description>with code delimiter</description>
			<behavior>
				<append>[$[counter]]($[from];$[to]){
	$[code]
}{
	$[code delimiter]
}</append>
			</behavior>
		</completion>
	
<!-- G -->
<!-- H -->
<!-- I -->
		<completion string="if">
			<behavior>
				<append>($[expression]){$[code]}</append>
			</behavior>
		</completion>
<!-- J -->
<!-- K -->
<!-- L -->
<!-- M -->
<!-- N -->
<!-- O -->
<!-- P -->
		<completion string="process">
			<behavior>
				<append>{$[string]}</append>
			</behavior>
		</completion>
		<completion string="process">
			<behavior>
				<append>[$[context]]{$[string]}</append>
			</behavior>
		</completion>
		<completion string="process">
			<behavior>
				<append>[$[context]]{$[string]}[$[options]]</append>
			</behavior>
		</completion>
<!-- Q -->
<!-- R -->
		<completion string="rem">
			<behavior>
				<append>{$[comment]}</append>
			</behavior>
		</completion>
		
		<completion string="return">
			<behavior>
				<append>[]</append>
			</behavior>
		</completion>
		<completion string="return">
			<behavior>
				<append>[$[result]]</append>
			</behavior>
		</completion>

<!-- S -->
		<completion string="sleep">
			<behavior>
				<append>($[seconds])</append>
			</behavior>
		</completion>

		<completion string="switch">
			<description>string to compare</description>
			<behavior>
				<append>[$[string]]{
	^case[$[1]]{
		
	}
	^case[$[2]]{
		
	}
}</append>
			</behavior>
		</completion>
		<completion string="switch">
			<description>mathematical expression</description>
			<behavior>
				<append>($[expression]){
	^case($[1]){
		
	}
	^case($[2]){
		
	}
}</append>
			</behavior>
		</completion>
<!-- T -->
		<completion string="taint">
			<behavior>
				<append>[$[text]]</append>
			</behavior>
		</completion>
		<completion string="taint">
			<behavior>
				<append>[$[type of transformation]][$[text]]</append>
			</behavior>
		</completion>
		
		<completion string="throw">
			<behavior>
				<append>[$[type]]</append>
			</behavior>
		</completion>
		<completion string="throw">
			<behavior>
				<append>[$[type];$[source]]</append>
			</behavior>
		</completion>
		<completion string="throw">
			<behavior>
				<append>[$[type];$[source];$[comment]]</append>
			</behavior>
		</completion>
		<completion string="throw">
			<behavior>
				<append>[$[hash]]</append>
			</behavior>
		</completion>

		<completion string="try">
			<description>try{ code }{ exception handler }</description>
			<behavior>
				<append>{
	$[code]
}{
	$[exception handler]
}</append>
			</behavior>
		</completion>
		<completion string="try">
			<description>try{ code }{ exception handler }{ code which will be executed anyway }</description>
			<behavior>
				<append>{
	$[code]
}{
	$[exception handler]
}{
	$[ code ]
}</append>
			</behavior>
		</completion>

<!-- U -->
		<completion string="untaint">
			<behavior>
				<append>{$[code]}</append>
			</behavior>
		</completion>
		<completion string="untaint">
			<behavior>
				<append>[$[type of transformation]]{$[code]}</append>
			</behavior>
		</completion>

		<completion string="use">
			<behavior>
				<append>[$[file]]</append>
			</behavior>
		</completion>
		<completion string="use">
			<behavior>
				<append>[$[file];$[options]]</append>
			</behavior>
		</completion>
<!-- V -->
<!-- W -->
		<completion string="while">
			<behavior>
				<append>($[condition]){
	$[code]
}</append>
			</behavior>
		</completion>
		<completion string="while">
			<description>with string delimiter</description>
			<behavior>
				<append>($[condition]){
	$[code]
}[$[string delimiter]]</append>
			</behavior>
		</completion>
		<completion string="while">
			<description>with code delimiter</description>
			<behavior>
				<append>($[condition]){
	$[code]
}{
	$[code delimiter]
}</append>
			</behavior>
		</completion>
<!-- X -->
<!-- Y -->
<!-- Z -->
	</set>
	
</completions>
